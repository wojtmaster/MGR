classdef DMC < handle
    properties
        N
        Nu
        D
        M
        M_matrix
        M_p
        Mp_matrix
        K
        ke
        ku
        lambda

        u_max = 10;
        delta_uk_max = 2.5;
    end

    methods
        function obj = DMC(N, Nu, D, lambda)
            obj.N = N;
            obj.Nu = Nu;
            obj.D = D;
            obj.lambda = lambda;
        end

        function [] = dynamic_matrix(obj, s)
            obj.M = cell(obj.N, obj.Nu);

            % Implementacja macierzy M
            for i = 1:obj.N
                for j = 1:obj.Nu
                    if(i >= j)
                        obj.M{i,j} = s{i-j+1};
                    else
                        obj.M{i,j} = zeros(2,2);
                    end
                end
            end

            obj.M_matrix = cell2mat(obj.M);
            I = eye(obj.Nu*2) * obj.lambda;

            % Macierz K
            obj.K = ((obj.M_matrix' * obj.M_matrix + I)^(-1)) * obj.M_matrix';
            for i = 1:2
                for j = 1:2
                    obj.ke(i,j) = sum(obj.K(i, j:2:end));
                end
            end
        end

        function [] = past_matrix(obj, s)
            obj.M_p = cell(obj.N, obj.D-1);
        
            % Implementacja macierzy M_p
            for i = 1:obj.N
                for j = 1:obj.D-1
                    if(i+j <= obj.D)
                        obj.M_p{i,j} = s{i+j} - s{j};
                    else 
                        obj.M_p{i,j} = s{obj.D} - s{j};
                    end
                end
            end
            obj.Mp_matrix = cell2mat(obj.M_p);
            obj.ku = obj.K(1:2, :) * obj.Mp_matrix;
        end

        function [y, u, E, E_u, E_y] = dmc_analiticHammerstein(obj, y_zad, a_h, b_h, a_pH, b_pH, obiekt)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v.h, v.Wa4, v.Wb4, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);

            for k = 4:obiekt.kk
                v.h(k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+u(1,k-1)+u(2,k-1))/obiekt.C_V)^2 - obiekt.h_0;
                y(1, k) = - a_h*y(1, k-1) + b_h*v.h(k-1)';

                v.Wa4(k) = (obiekt.W_a1*(obiekt.Q_10+u(1,k-1))+obiekt.W_a2*obiekt.Q_20+obiekt.W_a3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.Wb4(k) = (obiekt.W_b1*(obiekt.Q_10+u(1,k-1))+obiekt.W_b2*obiekt.Q_20+obiekt.W_b3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.pH(k) = obiekt.pH_calc(v.Wa4(k), v.Wb4(k)) - obiekt.pH_0;
                y(2, k) = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k-1:-1:k-2)' + (-b_pH.Q1 + b_pH.Q3)/2 * v.pH(k:-1:k-1)';
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk', delta_up(1:end-2)];
        
                % Obliczenie uchybu    
                e = [y_zad(1, k) - y(1, k);
                    y_zad(2, k) - y(2, k - 3)];
            
                % Obliczenie przyrostu sterowania dla chwili (i+1) w chwili i-tej
                delta_uk = obj.ke * e - obj.ku * delta_up';

                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;     
        end

        function [y, u, E, E_u, E_y] = dmc_numericHammerstein(obj, y_zad, a_h, b_h, a_pH, b_pH, obiekt)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v.h, v.Wa4, v.Wb4, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);
        
            Y_max = ones(obj.N,2)*Inf;
            Y_min = ones(obj.N,2)*(-Inf);
            
            U_max = ones(obj.Nu,2)*obj.u_max;
            U_min = ones(obj.Nu,2)*(-obj.u_max);
            delta_U_max = ones(obj.Nu,2)*obj.delta_uk_max;
            delta_U_min = ones(obj.Nu,2)*(-obj.delta_uk_max);
            
            I = eye(obj.Nu*2) * obj.lambda;

            J = tril(ones(obj.Nu*2));
            A = [-J; J; -obj.M_matrix; obj.M_matrix];
            H = 2*(obj.M_matrix'*obj.M_matrix + I);
            
            for k = 4:obiekt.kk
                v.h(k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+u(1,k-1)+u(2,k-1))/obiekt.C_V)^2 - obiekt.h_0;
                y(1, k) = - a_h*y(1, k-1) + b_h*v.h(k-1)';

                v.Wa4(k) = (obiekt.W_a1*(obiekt.Q_10+u(1,k-1))+obiekt.W_a2*obiekt.Q_20+obiekt.W_a3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.Wb4(k) = (obiekt.W_b1*(obiekt.Q_10+u(1,k-1))+obiekt.W_b2*obiekt.Q_20+obiekt.W_b3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.pH(k) = obiekt.pH_calc(v.Wa4(k), v.Wb4(k)) - obiekt.pH_0;
                y(2, k) = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k-1:-1:k-2)' + (-b_pH.Q1 + b_pH.Q3)/2 * v.pH(k:-1:k-1)';
        
                %% DMC
                delta_up = [delta_uk(1:2)', delta_up(1:end-2)];  % np. nu=2
            
                % Referencje
                Y_zad = reshape(y_zad(:,k), [], 1);
                Y_zad_vec = repmat(Y_zad, obj.N, 1); % rozmiar: (2*N x 1)
                Y = [y(1,k); y(2, k-3)]; % aktualna wartość
                Y0 = repmat(Y, obj.N, 1) + obj.Mp_matrix * delta_up';
                f = -2 * obj.M_matrix' * (Y_zad_vec - Y0); % Gradient funkcji celu
                % Ograniczenia
                U_k_1 = repmat(u(:,k-1), obj.Nu, 1); % rozmiar: (2*Nu x 1)
                B = [
                    -U_min(:) + U_k_1;
                     U_max(:) - U_k_1;
                    -Y_min(:) + Y0;
                     Y_max(:) - Y0
                ];
                
                % QP
                options = optimoptions('quadprog', 'Display', 'off');
                delta_uk_all = quadprog(H, f, A, B, [], [], delta_U_min(:), delta_U_max(:), [], options);
            
                % Aktualizacja sterowania
                delta_uk = delta_uk_all(1:2); % tylko pierwszy krok sterowania (na bieżąco)
                
                % Ograniczenia przyrostów (dodatkowo)
                delta_uk = max(min(delta_uk, obj.delta_uk_max), -obj.delta_uk_max);
                delta_u(:, k) = delta_uk;
                
                u(:, k) = u(:, k-1) + delta_uk;
                u(:, k) = max(min(u(:, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;   
        end

        function [y, u, E, E_u, E_y] = dmc_fuzzyHammerstein(obj, y_zad, a_h, b_h, a_pH, b_pH, obiekt)
            gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
        
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v.h, v.Wa4, v.Wb4, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);
        
            Q_10 = obiekt.Q_10;
            Q_30 = obiekt.Q_30;
            h_0 = obiekt.h_0;
            pH_0 = obiekt.pH_0;
            lambda_original = obj.lambda;
        
            Q_1 = [-10 0 10];
            Q_3 = [-10 0 10];
            sigma = 10;
            rules_number = length(Q_1);
            Y = zeros(2, rules_number);
            KE = cell(1, rules_number);
            KU = cell(1, rules_number);
        
            for i = 1:rules_number
                obiekt.linearization(Q_10+Q_1(i), obiekt.Q_20, Q_30+Q_3(i));
                [~, ~, s_h] = obiekt.fopdtModel('h', 1);
                [~, ~, s_pH] = obiekt.tfestModel();

                S = cell(1, obiekt.dynamic_horizont);
                
                for j = 1:obiekt.dynamic_horizont
                    S{j} = [s_h.Q1(j), s_h.Q3(j)
                            s_pH.Q1(j), s_pH.Q3(j)];
                end

                obj.dynamic_matrix(S);
                obj.past_matrix(S);
        
                Y(1, i) = obiekt.h_0 - h_0;
                Y(2, i) = obiekt.pH_0 - pH_0;
                KE{i} = obj.ke;
                KU{i} = obj.ku;
            end

            obiekt.Q_10 = Q_10;
            obiekt.Q_30 = Q_30;
            obiekt.h_0 = h_0;
            obiekt.pH_0 = pH_0;
            obj.lambda = lambda_original;
        
            %% Sterowanie DMC
            for k = 4:obiekt.kk
                v.h(k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+u(1,k-1)+u(2,k-1))/obiekt.C_V)^2 - obiekt.h_0;
                y(1, k) = - a_h*y(1, k-1) + b_h*v.h(k-1)';

                v.Wa4(k) = (obiekt.W_a1*(obiekt.Q_10+u(1,k-1))+obiekt.W_a2*obiekt.Q_20+obiekt.W_a3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.Wb4(k) = (obiekt.W_b1*(obiekt.Q_10+u(1,k-1))+obiekt.W_b2*obiekt.Q_20+obiekt.W_b3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.pH(k) = obiekt.pH_calc(v.Wa4(k), v.Wb4(k)) - obiekt.pH_0;
                y(2, k) = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k-1:-1:k-2)' + (-b_pH.Q1 + b_pH.Q3)/2 * v.pH(k:-1:k-1)';
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk', delta_up(1:end-2)];
        
                % Obliczenie uchybu    
                e = [y_zad(1, k) - y(1, k);
                    y_zad(2, k) - y(2, k - 3)];
        
                output = 0;
                w = 0;
                for i = 1:rules_number
                    degree_h = gaussmf_val(y(1, k), sigma, Y(1, i));
                    degree_pH = gaussmf_val(y(2, k), sigma, Y(2, i));
                    degree = degree_h * degree_pH;
                    output = output + degree * (KE{i} * e - KU{i} * delta_up');
                    w = w + degree;
                end
                delta_uk = output / w;

                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;   
        end

        function [y, u, E, E_u, E_y] = dmc_noHammerstein(obj, y_zad, a_h, b_h, a_pH, b_pH, obiekt)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);

            delta_uk = zeros(2, 1);
            delta_u_hist = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v.h, v.Wa4, v.Wb4, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);
        
            for k = 4:obiekt.kk
                v.h(k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+u(1,k-1)+u(2,k-1))/obiekt.C_V)^2 - obiekt.h_0;
                y(1, k) = - a_h*y(1, k-1) + b_h*v.h(k-1)';

                v.Wa4(k) = (obiekt.W_a1*(obiekt.Q_10+u(1,k-1))+obiekt.W_a2*obiekt.Q_20+obiekt.W_a3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.Wb4(k) = (obiekt.W_b1*(obiekt.Q_10+u(1,k-1))+obiekt.W_b2*obiekt.Q_20+obiekt.W_b3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.pH(k) = obiekt.pH_calc(v.Wa4(k), v.Wb4(k)) - obiekt.pH_0;
                y(2, k) = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k-1:-1:k-2)' + (-b_pH.Q1 + b_pH.Q3)/2 * v.pH(k:-1:k-1)';
                
                cost_func = @(du) sum(sum((y_zad(:,k)' .* ones(obj.N,1) ...
                    - nonlinear_func(v, u, y, reshape(du, obj.Nu, 2), k, a_h, b_h, a_pH, b_pH, obj.N)).^2)) ...
                    + obj.lambda * sum(du.^2);
  
                % Ograniczenia na przyrosty sterowania
                lb = -obj.delta_uk_max * ones(2*obj.Nu, 1);
                ub = obj.delta_uk_max * ones(2*obj.Nu, 1);
                
                % Optymalizacja
                options = optimoptions('fmincon', 'Display', 'none', ...
                    'Algorithm', 'sqp', 'OptimalityTolerance', 1e-6, 'StepTolerance', 1e-6);
                delta_u = fmincon(cost_func, zeros(2*obj.Nu, 1), [], [], [], [], lb, ub, [], options);
                delta_uk(1) = delta_u(1);
                delta_uk(2) = delta_u(1+obj.Nu);
                delta_u_hist(1, k) = delta_uk(1);
                delta_u_hist(2, k) = delta_uk(2);
        
                % Aktualizacja sterowania
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;     
        
            function y_pred = nonlinear_func(v, u, y, du, k, a_h, b_h, a_pH, b_pH, N)
                y_pred = zeros(N,2);
                [v_pred.h, v_pred.Wa4, v_pred.Wb4, v_pred.pH] = deal(zeros(N,1));
                u_pred = zeros(N,2);
            
                for i = 1:N
                    % wyliczenie przyrostu sterowania
                    if i <= size(du,1)
                        du_i = du(i, :);  % [du1, du2]
                    else
                        du_i = du(end, :);
                    end

                    % Predykcja sterowania
                    if i == 1
                        u1_now = u(1, k-1) + du_i(1);
                        u2_now = u(2, k-1) + du_i(2);
                    else
                        u1_now = u_pred(i-1,1) + du_i(1);
                        u2_now = u_pred(i-1,2) + du_i(2);
                    end
                    u_pred(i, :) = [u1_now, u2_now];
            
                    % predykcja stanu
                    v_pred.h(i) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+u1_now+u2_now)/obiekt.C_V)^2 - obiekt.h_0;

                    v_pred.Wa4(i) = (obiekt.W_a1*(obiekt.Q_10+u1_now)+obiekt.W_a2*obiekt.Q_20+obiekt.W_a3*(obiekt.Q_30+u2_now)) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u1_now + u2_now);
                    v_pred.Wb4(i) = (obiekt.W_b1*(obiekt.Q_10+u1_now)+obiekt.W_b2*obiekt.Q_20+obiekt.W_b3*(obiekt.Q_30+u2_now)) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u1_now + u2_now);
                    v_pred.pH(i) = obiekt.pH_calc(v_pred.Wa4(i), v_pred.Wb4(i)) - obiekt.pH_0;
            
                    if i == 1
                        y_pred(i, 1) = -a_h * y(1, k)+ b_h * v.h(k);
                        y_pred(i, 2) = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k:-1:k-1)' + (-b_pH.Q1 + b_pH.Q3)/2 * [v_pred.pH(i) v.pH(k)]';
                    elseif i == 2
                        y_pred(i, 1) = -a_h * y_pred(i-1, 1) + b_h * v_pred.h(i-1);
                        y_pred(i, 2) = -(a_pH.Q1 + a_pH.Q3)/2 * [y_pred(i-1, 2) y(2, k)]' + (-b_pH.Q1 + b_pH.Q3)/2 * [v_pred.pH(i) v_pred.pH(i-1)]';
                    else
                        y_pred(i, 1) = -a_h * y_pred(i-1, 1) + b_h * v_pred.h(i-1);
                        y_pred(i, 2) = -(a_pH.Q1 + a_pH.Q3)/2 * [y_pred(i-1, 2) y_pred(i-2, 2)]' + (-b_pH.Q1 + b_pH.Q3)/2 * [v_pred.pH(i) v_pred.pH(i-1)]';
                    end
                end
            end
        end

        function [y, u, E, E_u, E_y] = dmc_slHammerstein(obj, y_zad, a_h, b_h, a_pH, b_pH, obiekt, fis, type)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v.h, v.Wa4, v.Wb4, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);

            I = eye(obj.Nu*2) * obj.lambda;

            for k = 4:obiekt.kk

                if (strcmp(type, 'linear'))
                    h = evalfis(fis.h, [u(1,k-1), u(2,k-1)]);
                    Wa4 = evalfis(fis.Wa4, [u(1,k-1), u(2,k-1)]);
                    Wb4 = evalfis(fis.Wb4, [u(1,k-1), u(2,k-1)]);
                else
                    h = evalfis(fis.h, [sinh(u(1,k-1)/15), sinh(u(2,k-1)/15)]);
                    Wa4 = evalfis(fis.Wa4, [tanh(u(1,k-1)'/15) tanh(u(2,k-1)'/15)]);
                    Wb4 = evalfis(fis.Wb4, [sinh(u(1,k-1)'/15) sinh(u(2,k-1)'/15)]);
                end

                pH = obiekt.pH_calc(Wa4 + obiekt.W_a40, Wb4 + obiekt.W_b40) - obiekt.pH_0;

                if (u(1,k-1) + u(2, k-1) ~= 0)
                    dydu.h = h / (u(1,k-1) + u(2, k-1));
                else
                    dydu.h = 1;
                end

                if (-u(1,k-1) + u(2, k-1) ~= 0)
                    dydu.pH = pH / (-u(1,k-1) + u(2, k-1));
                else
                    dydu.pH = 1;
                end

                for i = 1:2:size(obj.M_matrix, 1)
                    M_new(i, :)   = dydu.h  * obj.M_matrix(i, :);
                    M_new(i+1, :) = dydu.pH * obj.M_matrix(i+1, :);
                end
                K_new = (M_new' * M_new + I)^(-1) * M_new';
                for i = 1:2
                    for j = 1:2
                        ke_new(i,j) = sum(K_new(i, j:2:end));
                    end
                end
        
                for i = 1:2:size(obj.Mp_matrix, 1)
                    Mp_new(i, :)   = dydu.h  * obj.Mp_matrix(i, :);
                    Mp_new(i+1, :) = dydu.pH * obj.Mp_matrix(i+1, :);
                end
                ku_new = K_new(1:2, :) * Mp_new;
                
                v.h(k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+u(1,k-1)+u(2,k-1))/obiekt.C_V)^2 - obiekt.h_0;
                y(1, k) = - a_h*y(1, k-1) + b_h*v.h(k-1)';

                v.Wa4(k) = (obiekt.W_a1*(obiekt.Q_10+u(1,k-1))+obiekt.W_a2*obiekt.Q_20+obiekt.W_a3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.Wb4(k) = (obiekt.W_b1*(obiekt.Q_10+u(1,k-1))+obiekt.W_b2*obiekt.Q_20+obiekt.W_b3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.pH(k) = obiekt.pH_calc(v.Wa4(k), v.Wb4(k)) - obiekt.pH_0;
                y(2, k) = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k-1:-1:k-2)' + (-b_pH.Q1 + b_pH.Q3)/2 * v.pH(k:-1:k-1)';
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk', delta_up(1:end-2)];
        
                % Obliczenie uchybu    
                e = [y_zad(1, k) - y(1, k);
                    y_zad(2, k) - y(2, k - 3)];
            
                % Obliczenie przyrostu sterowania dla chwili (i+1) w chwili i-tej
                delta_uk = ke_new * e - ku_new * delta_up';

                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;     
        end

        function [y, u, E, E_u, E_y] = dmc_nplHammerstein(obj, y_zad, a_h, b_h, a_pH, b_pH, obiekt, fis, type)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v.h, v.Wa4, v.Wb4, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);

            I = eye(obj.Nu*2) * obj.lambda;

            for k = 3:obiekt.kk
                
                % Obliczenie wzmocnienia z modelu Hammersteina
                if (strcmp(type, 'linear'))
                    h = evalfis(fis.h, [u(1,k-1), u(2,k-1)]);
                    Wa4 = evalfis(fis.Wa4, [u(1,k-1), u(2,k-1)]);
                    Wb4 = evalfis(fis.Wb4, [u(1,k-1), u(2,k-1)]);
                else
                    h = evalfis(fis.h, [sinh(u(1,k-1)/15), sinh(u(2,k-1)/15)]);
                    Wa4 = evalfis(fis.Wa4, [tanh(u(1,k-1)/15) tanh(u(2,k-1)/15)]);
                    Wb4 = evalfis(fis.Wb4, [sinh(u(1,k-1)/15) sinh(u(2,k-1)/15)]);
                end
                
                pH = obiekt.pH_calc(Wa4 + obiekt.W_a40, Wb4 + obiekt.W_b40) - obiekt.pH_0;

                if (u(1,k-1) + u(2, k-1) ~= 0)
                    dydu.h = h / (u(1,k-1) + u(2, k-1));
                else
                    dydu.h = 1;
                end

                if (-u(1,k-1) + u(2, k-1) ~= 0)
                    dydu.pH = pH / (-u(1,k-1) + u(2, k-1));
                else
                    dydu.pH = 1;
                end

                for i = 1:2:size(obj.M_matrix, 1)
                    M_new(i, :)   = dydu.h  * obj.M_matrix(i, :);
                    M_new(i+1, :) = dydu.pH * obj.M_matrix(i+1, :);
                end
                K_new = (M_new' * M_new + I)^(-1) * M_new';
                
                v.h(k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+u(1,k-1)+u(2,k-1))/obiekt.C_V)^2 - obiekt.h_0;
                y(1, k) = - a_h*y(1, k-1) + b_h*v.h(k-1)';

                v.Wa4(k) = (obiekt.W_a1*(obiekt.Q_10+u(1,k-1))+obiekt.W_a2*obiekt.Q_20+obiekt.W_a3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.Wb4(k) = (obiekt.W_b1*(obiekt.Q_10+u(1,k-1))+obiekt.W_b2*obiekt.Q_20+obiekt.W_b3*(obiekt.Q_30+u(2,k-1))) / (obiekt.Q_10+obiekt.Q_20+obiekt.Q_30 + u(1,k-1) + u(2,k-1));
                v.pH(k) = obiekt.pH_calc(v.Wa4(k), v.Wb4(k)) - obiekt.pH_0;
                y(2, k) = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k-1:-1:k-2)' + (-b_pH.Q1 + b_pH.Q3)/2 * v.pH(k:-1:k-1)';
        
                Y_0 = fuzzy_free_response(u, v, y, k, a_h, b_h, a_pH, b_pH, obj.N, fis, type);
                Y_0_mod = [Y_0(:,1), [Y_0(3:end,2); Y_0(end,2); Y_0(end,2)]];
                Y_zad = y_zad(:, k)' .* ones(obj.N, 1);
                e = (Y_zad - Y_0_mod)'; 
                e_vec = e(:);
                delta_uk = K_new(1:2,:) * e_vec;
        
                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
        
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end

            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;

            function y_0 = fuzzy_free_response(u, v, y, k, a_h, b_h, a_pH, b_pH, N, fis, type)
                y_0 = zeros(N, 2);
                v_0.h =  v.h(k);
                v_0.pH = v.pH(k);
        
                if (strcmp(type, 'linear'))
                    v_hat.h = evalfis(fis.h, [u(1, k-1), u(2, k-1)]);
                    v_hat.Wa4 = evalfis(fis.Wa4, [u(1, k-1), u(2, k-1)]);
                    v_hat.Wb4 = evalfis(fis.Wb4, [u(1, k-1), u(2, k-1)]);
                else
                    v_hat.h = evalfis(fis.h, [sinh(u(1, k-1)/15), sinh(u(2, k-1)/15)]);
                    v_hat.Wa4 = evalfis(fis.Wa4, [tanh(u(1, k-1)/15), tanh(u(2, k-1)/15)]);
                    v_hat.Wb4 = evalfis(fis.Wb4, [sinh(u(1, k-1)/15), sinh(u(2, k-1)/15)]);
                end
                v_hat.pH = obiekt.pH_calc(v_hat.Wa4+obiekt.W_a40, v_hat.Wb4+obiekt.W_b40) - obiekt.pH_0;
                
                y_hat.h = -a_h * y(1, k-1) + b_h * v_hat.h; 
                y_hat.pH = -(a_pH.Q1 + a_pH.Q3)/2 * y(2, k-1:-1:k-2)' + (-b_pH.Q1 + b_pH.Q3)/2 * [v_hat.pH v.pH(k)]';
                % dk.h = y(1, k) - y_hat.h;
                % dk.pH = y(2, k) - y_hat.pH;
                dk.h = 0;
                dk.pH = 0;
        
                for m = 1:N
                    if m == 1
                        y_0(m, 1) = -a_h*y(1, k) + b_h*v_0.h + dk.h;
                        y_0(m, 2) = -(a_pH.Q1 + a_pH.Q3)/2 * [y(2, k-1) y(2, k-2)]' + (-b_pH.Q1 + b_pH.Q3)/2 * [v_0.pH v_0.pH]' + dk.pH;
                    elseif m == 2
                        y_0(m, 1) = -a_h*y_0(m-1, 1) + b_h*v_0.h + dk.h;
                        y_0(m, 2) = -(a_pH.Q1 + a_pH.Q3)/2 * [y_0(m-1, 2) y(2, k)]' + (-b_pH.Q1 + b_pH.Q3)/2 * [v_0.pH v_0.pH]' + dk.pH;
                    else
                        y_0(m, 1) = -a_h*y_0(m-1, 1) + b_h*v_0.h + dk.h;
                        y_0(m, 2) = -(a_pH.Q1 + a_pH.Q3)/2 * [y_0(m-1, 2) y_0(m-2, 2)]' + (-b_pH.Q1 + b_pH.Q3)/2 * [v_0.pH v_0.pH]' + dk.pH;
                    end
                end
            end
        end

        function [y, u, E, E_u, E_y] = dmc_analiticWiener(obj, y_zad, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obiekt)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v_h.Q1, v_h.Q3, v_Wa4.Q1, v_Wa4.Q3, v_Wb4.Q1, v_Wb4.Q3, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);

            for k = 4:obiekt.kk
                v_h.Q1(k) = - a_h*v_h.Q1(k-1) + b_h*u(1, k-1);
                v_h.Q3(k) = - a_h*v_h.Q3(k-1) + b_h*u(2, k-1);
                y(1, k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_h.Q1(k)+v_h.Q3(k)) / obiekt.C_V).^2 - obiekt.h_0;
                
                v_Wa4.Q1(k) = - a_Wa4*v_Wa4.Q1(k-1) + b_Wa4*u(1, k-1);
                v_Wa4.Q3(k) = - a_Wa4*v_Wa4.Q3(k-1) - b_Wa4*u(2, k-1);
                v_Wb4.Q1(k) = - a_Wb4*v_Wb4.Q1(k-1) + b_Wb4*u(1, k-1);
                v_Wb4.Q3(k) = - a_Wb4*v_Wb4.Q3(k-1) + b_Wb4*u(2, k-1);

                Wa4 = (obiekt.W_a1*(obiekt.Q_10+v_Wa4.Q1(k)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30-v_Wa4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_Wa4.Q1(k)-v_Wa4.Q3(k));
                Wb4 = (obiekt.W_b1*(obiekt.Q_10-v_Wb4.Q1(k)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30-v_Wb4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30-v_Wb4.Q1(k)-v_Wb4.Q3(k));
                y(2, k) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk', delta_up(1:end-2)];
        
                % Obliczenie uchybu    
                e = [y_zad(1, k) - y(1, k);
                    y_zad(2, k) - y(2, k - 3)];
            
                % Obliczenie przyrostu sterowania dla chwili (i+1) w chwili i-tej
                delta_uk = obj.ke * e - obj.ku * delta_up';

                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end

            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;
        end

        function [y, u, E, E_u, E_y] = dmc_numericWiener(obj, y_zad, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obiekt)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v_h.Q1, v_h.Q3, v_Wa4.Q1, v_Wa4.Q3, v_Wb4.Q1, v_Wb4.Q3, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);
        
            Y_max = ones(obj.N,2)*Inf;
            Y_min = ones(obj.N,2)*(-Inf);
            
            U_max = ones(obj.Nu,2)*obj.u_max;
            U_min = ones(obj.Nu,2)*(-obj.u_max);
            delta_U_max = ones(obj.Nu,2)*obj.delta_uk_max;
            delta_U_min = ones(obj.Nu,2)*(-obj.delta_uk_max);
            
            I = eye(obj.Nu*2) * obj.lambda;

            J = tril(ones(obj.Nu*2));
            A = [-J; J; -obj.M_matrix; obj.M_matrix];
            H = 2*(obj.M_matrix'*obj.M_matrix + I);

            for k = 4:obiekt.kk
                v_h.Q1(k) = - a_h*v_h.Q1(k-1) + b_h*u(1, k-1);
                v_h.Q3(k) = - a_h*v_h.Q3(k-1) + b_h*u(2, k-1);
                y(1, k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_h.Q1(k)+v_h.Q3(k)) / obiekt.C_V).^2 - obiekt.h_0;
                
                v_Wa4.Q1(k) = - a_Wa4*v_Wa4.Q1(k-1) + b_Wa4*u(1, k-1);
                v_Wa4.Q3(k) = - a_Wa4*v_Wa4.Q3(k-1) - b_Wa4*u(2, k-1);
                v_Wb4.Q1(k) = - a_Wb4*v_Wb4.Q1(k-1) + b_Wb4*u(1, k-1);
                v_Wb4.Q3(k) = - a_Wb4*v_Wb4.Q3(k-1) + b_Wb4*u(2, k-1);

                Wa4 = (obiekt.W_a1*(obiekt.Q_10+v_Wa4.Q1(k)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30-v_Wa4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_Wa4.Q1(k)-v_Wa4.Q3(k));
                Wb4 = (obiekt.W_b1*(obiekt.Q_10-v_Wb4.Q1(k)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30-v_Wb4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30-v_Wb4.Q1(k)-v_Wb4.Q3(k));
                y(2, k) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk', delta_up(1:end-2)];
            
                % Referencje
                Y_zad = reshape(y_zad(:,k), [], 1);
                Y_zad_vec = repmat(Y_zad, obj.N, 1); % rozmiar: (2*N x 1)
                Y = [y(1,k); y(2, k-3)]; % aktualna wartość
                Y0 = repmat(Y, obj.N, 1) + obj.Mp_matrix * delta_up';
                f = -2 * obj.M_matrix' * (Y_zad_vec - Y0); % Gradient funkcji celu
                % Ograniczenia
                U_k_1 = repmat(u(:,k-1), obj.Nu, 1); % rozmiar: (2*Nu x 1)
                B = [
                    -U_min(:) + U_k_1;
                     U_max(:) - U_k_1;
                    -Y_min(:) + Y0;
                     Y_max(:) - Y0
                ];
                
                % QP
                options = optimoptions('quadprog', 'Display', 'off');
                delta_uk_all = quadprog(H, f, A, B, [], [], delta_U_min(:), delta_U_max(:), [], options);
            
                % Aktualizacja sterowania
                delta_uk = delta_uk_all(1:2); % tylko pierwszy krok sterowania (na bieżąco)
                
                % Ograniczenia przyrostów (dodatkowo)
                delta_uk = max(min(delta_uk, obj.delta_uk_max), -obj.delta_uk_max);
                delta_u(:, k) = delta_uk;
                
                u(:, k) = u(:, k-1) + delta_uk;
                u(:, k) = max(min(u(:, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;  
        end

        function [y, u, E, E_u, E_y] = dmc_fuzzyWiener(obj, y_zad, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obiekt)
            gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
        
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v_h.Q1, v_h.Q3, v_Wa4.Q1, v_Wa4.Q3, v_Wb4.Q1, v_Wb4.Q3, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);
        
            Q_10 = obiekt.Q_10;
            Q_30 = obiekt.Q_30;
            h_0 = obiekt.h_0;
            pH_0 = obiekt.pH_0;
            lambda_original = obj.lambda;
        
            Q_1 = [-10 0 10];
            Q_3 = [-10 0 10];
            sigma = 10;
            rules_number = length(Q_1);
            Y = zeros(2, rules_number);
            KE = cell(1, rules_number);
            KU = cell(1, rules_number);
        
            for i = 1:rules_number
                obiekt.linearization(Q_10+Q_1(i), obiekt.Q_20, Q_30+Q_3(i));
                [~, ~, s_h] = obiekt.fopdtModel('h', 1);
                [~, ~, s_pH] = obiekt.tfestModel();

                S = cell(1, obiekt.dynamic_horizont);
                
                for j = 1:obiekt.dynamic_horizont
                    S{j} = [s_h.Q1(j), s_h.Q3(j)
                            s_pH.Q1(j), s_pH.Q3(j)];
                end

                obj.dynamic_matrix(S);
                obj.past_matrix(S);
        
                Y(1, i) = obiekt.h_0 - h_0;
                Y(2, i) = obiekt.pH_0 - pH_0;
                KE{i} = obj.ke;
                KU{i} = obj.ku;
            end

            obiekt.Q_10 = Q_10;
            obiekt.Q_30 = Q_30;
            obiekt.h_0 = h_0;
            obiekt.pH_0 = pH_0;
            obj.lambda = lambda_original;

            %% Sterowanie DMC
            for k = 4:obiekt.kk
                v_h.Q1(k) = - a_h*v_h.Q1(k-1) + b_h*u(1, k-1);
                v_h.Q3(k) = - a_h*v_h.Q3(k-1) + b_h*u(2, k-1);
                y(1, k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_h.Q1(k)+v_h.Q3(k)) / obiekt.C_V).^2 - obiekt.h_0;
                
                v_Wa4.Q1(k) = - a_Wa4*v_Wa4.Q1(k-1) + b_Wa4*u(1, k-1);
                v_Wa4.Q3(k) = - a_Wa4*v_Wa4.Q3(k-1) - b_Wa4*u(2, k-1);
                v_Wb4.Q1(k) = - a_Wb4*v_Wb4.Q1(k-1) + b_Wb4*u(1, k-1);
                v_Wb4.Q3(k) = - a_Wb4*v_Wb4.Q3(k-1) + b_Wb4*u(2, k-1);

                Wa4 = (obiekt.W_a1*(obiekt.Q_10+v_Wa4.Q1(k)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30-v_Wa4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_Wa4.Q1(k)-v_Wa4.Q3(k));
                Wb4 = (obiekt.W_b1*(obiekt.Q_10-v_Wb4.Q1(k)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30-v_Wb4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30-v_Wb4.Q1(k)-v_Wb4.Q3(k));
                y(2, k) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk', delta_up(1:end-2)];
        
                % Obliczenie uchybu    
                e = [y_zad(1, k) - y(1, k);
                    y_zad(2, k) - y(2, k - 3)];
        
                output = 0;
                w = 0;
                for i = 1:rules_number
                    degree_h = gaussmf_val(y(1, k), sigma, Y(1, i));
                    degree_pH = gaussmf_val(y(2, k), sigma, Y(2, i));
                    degree = degree_h * degree_pH;
                    output = output + degree * (KE{i} * e - KU{i} * delta_up');
                    w = w + degree;
                end
                delta_uk = output / w;

                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;  
        end

        function [y, u, E, E_u, E_y] = dmc_noWiener(obj, y_zad, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obiekt)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
            delta_uk = zeros(2, 1);
            
            %% Sterowanie DMC
            [v_h.Q1, v_h.Q3, v_Wa4.Q1, v_Wa4.Q3, v_Wb4.Q1, v_Wb4.Q3, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);

            delta_u_hist = zeros(1, obiekt.kk);
            
            %% Sterowanie DMC        
            for k = obiekt.delay+3:obiekt.kk
                v_h.Q1(k) = - a_h*v_h.Q1(k-1) + b_h*u(1, k-1);
                v_h.Q3(k) = - a_h*v_h.Q3(k-1) + b_h*u(2, k-1);
                y(1, k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_h.Q1(k)+v_h.Q3(k)) / obiekt.C_V).^2 - obiekt.h_0;
                
                v_Wa4.Q1(k) = - a_Wa4*v_Wa4.Q1(k-1) + b_Wa4*u(1, k-1);
                v_Wa4.Q3(k) = - a_Wa4*v_Wa4.Q3(k-1) - b_Wa4*u(2, k-1);
                v_Wb4.Q1(k) = - a_Wb4*v_Wb4.Q1(k-1) + b_Wb4*u(1, k-1);
                v_Wb4.Q3(k) = - a_Wb4*v_Wb4.Q3(k-1) + b_Wb4*u(2, k-1);

                Wa4 = (obiekt.W_a1*(obiekt.Q_10+v_Wa4.Q1(k)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30-v_Wa4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_Wa4.Q1(k)-v_Wa4.Q3(k));
                Wb4 = (obiekt.W_b1*(obiekt.Q_10-v_Wb4.Q1(k)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30-v_Wb4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30-v_Wb4.Q1(k)-v_Wb4.Q3(k));
                y(2, k) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;

                cost_func = @(du) sum(sum((y_zad(:,k)' .* ones(obj.N,1) ...
                    - nonlinear_func(v_h, v_Wa4, v_Wb4, u, reshape(du, obj.Nu, 2), k, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obj.N)).^2)) ...
                    + obj.lambda * sum(du.^2);
  
                % Ograniczenia na przyrosty sterowania
                lb = -obj.delta_uk_max * ones(2*obj.Nu, 1);
                ub = obj.delta_uk_max * ones(2*obj.Nu, 1);
                
                % Optymalizacja
                options = optimoptions('fmincon', 'Display', 'none', ...
                    'Algorithm', 'sqp', 'OptimalityTolerance', 1e-6, 'StepTolerance', 1e-6);
                delta_u = fmincon(cost_func, zeros(2*obj.Nu, 1), [], [], [], [], lb, ub, [], options);
                delta_uk(1) = delta_u(1);
                delta_uk(2) = delta_u(1+obj.Nu);
                delta_u_hist(1, k) = delta_uk(1);
                delta_u_hist(2, k) = delta_uk(2);
        
                % Aktualizacja sterowania
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;
        
            function y_pred = nonlinear_func(v_h, v_Wa4, v_Wb4, u, du, k, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, N)
                
                y_pred = zeros(N,2);
                [v_pred.h_Q1, v_pred.h_Q3, v_pred.Wa4_Q1, v_pred.Wa4_Q3, v_pred.Wb4_Q1, v_pred.Wb4_Q3]  = deal(zeros(N,1));
                u_pred = zeros(N,2);
            
                for i = 1:N
                    if i <= size(du,1)
                        du_i = du(i, :);  % [du1, du2]
                    else
                        du_i = du(end, :);
                    end

                    % Predykcja sterowania
                    if i == 1
                        u1_now = u(1, k-1) + du_i(1);
                        u2_now = u(2, k-1) + du_i(2);
                    else
                        u1_now = u_pred(i-1,1) + du_i(1);
                        u2_now = u_pred(i-1,2) + du_i(2);
                    end
                    u_pred(i, :) = [u1_now, u2_now];

                    if i == 1
                        v_pred.h_Q1(i) = - a_h*v_h.Q1(k) + b_h*u(1, k-1);
                        v_pred.h_Q3(i) = - a_h*v_h.Q3(k) + b_h*u(2, k-1);
                        
                        v_pred.Wa4_Q1(i) = - a_Wa4*v_Wa4.Q1(k) + b_Wa4*u(1, k-1);
                        v_pred.Wa4_Q3(i) = - a_Wa4*v_Wa4.Q3(k) - b_Wa4*u(2, k-1);
                        v_pred.Wb4_Q1(i) = - a_Wb4*v_Wb4.Q1(k) + b_Wb4*u(1, k-1);
                        v_pred.Wb4_Q3(i) = - a_Wb4*v_Wb4.Q3(k) + b_Wb4*u(2, k-1);
                    else
                        v_pred.h_Q1(i) = - a_h*v_pred.h_Q1(i-1) + b_h*u1_now;
                        v_pred.h_Q3(i) = - a_h*v_pred.h_Q3(i-1) + b_h*u2_now;
                        
                        v_pred.Wa4_Q1(i) = - a_Wa4*v_pred.Wa4_Q1(i-1) + b_Wa4*u1_now;
                        v_pred.Wa4_Q3(i) = - a_Wa4*v_pred.Wa4_Q3(i-1) - b_Wa4*u2_now;
                        v_pred.Wb4_Q1(i) = - a_Wb4*v_pred.Wb4_Q1(i-1) + b_Wb4*u1_now;
                        v_pred.Wb4_Q3(i) = - a_Wb4*v_pred.Wb4_Q3(i-1) + b_Wb4*u2_now;
                    end
    
                    y_pred(i, 1) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_pred.h_Q1(i)+v_pred.h_Q3(i)) / obiekt.C_V).^2 - obiekt.h_0;
                    Wa4 = (obiekt.W_a1*(obiekt.Q_10+v_pred.Wa4_Q1(i)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30-v_pred.Wa4_Q3(i)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_pred.Wa4_Q1(i)-v_pred.Wa4_Q3(i));
                    Wb4 = (obiekt.W_b1*(obiekt.Q_10-v_pred.Wb4_Q1(i)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30-v_pred.Wb4_Q3(i)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30-v_pred.Wb4_Q1(i)-v_pred.Wb4_Q3(i));
                    y_pred(i, 2) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;
                end
            end
        end

        function [y, u, E, E_u, E_y] = dmc_slWiener(obj, y_zad, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obiekt, fis, type)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
        
            delta_up = zeros(1, 2*(obj.D-1));
            delta_uk = zeros(2, 1);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v_h.Q1, v_h.Q3, v_Wa4.Q1, v_Wa4.Q3, v_Wb4.Q1, v_Wb4.Q3, v.pH] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);

            I = eye(obj.Nu*2) * obj.lambda;

            for k = 4:obiekt.kk
                v_h.Q1(k) = - a_h*v_h.Q1(k-1) + b_h*u(1, k-1);
                v_h.Q3(k) = - a_h*v_h.Q3(k-1) + b_h*u(2, k-1);
                y(1, k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_h.Q1(k)+v_h.Q3(k)) / obiekt.C_V).^2 - obiekt.h_0;
                
                v_Wa4.Q1(k) = - a_Wa4*v_Wa4.Q1(k-1) + b_Wa4*u(1, k-1);
                v_Wa4.Q3(k) = - a_Wa4*v_Wa4.Q3(k-1) - b_Wa4*u(2, k-1);
                v_Wb4.Q1(k) = - a_Wb4*v_Wb4.Q1(k-1) + b_Wb4*u(1, k-1);
                v_Wb4.Q3(k) = - a_Wb4*v_Wb4.Q3(k-1) + b_Wb4*u(2, k-1);

                Wa4 = (obiekt.W_a1*(obiekt.Q_10+v_Wa4.Q1(k)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30-v_Wa4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_Wa4.Q1(k)-v_Wa4.Q3(k));
                Wb4 = (obiekt.W_b1*(obiekt.Q_10-v_Wb4.Q1(k)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30-v_Wb4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30-v_Wb4.Q1(k)-v_Wb4.Q3(k));
                y(2, k) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;

                if (strcmp(type, 'linear'))
                    h = evalfis(fis.h, [v_h.Q1(k), v_h.Q3(k)]);
                    Wa4 = evalfis(fis.Wa4, [v_Wa4.Q1(k), v_Wa4.Q3(k)]);
                    Wb4 = evalfis(fis.Wb4, [v_Wb4.Q1(k), v_Wb4.Q3(k)]);
                else
                    h = evalfis(fis.h, [sinh(v_h.Q1(k)/15), sinh(v_h.Q3(k)/15)]);
                    Wa4 = evalfis(fis.Wa4, [tanh(v_Wa4.Q1(k)/15) tanh(v_Wa4.Q3(k)/15)]);
                    Wb4 = evalfis(fis.Wb4, [sinh(v_Wa4.Q1(k)/15) sinh(v_Wa4.Q3(k)/15)]);
                end

                pH = obiekt.pH_calc(Wa4 + obiekt.W_a40, Wb4 + obiekt.W_b40) - obiekt.pH_0;

                if (u(1,k-1) + u(2, k-1) ~= 0)
                    dydv.h = h / (u(1,k-1) + u(2, k-1));
                else
                    dydv.h = 1;
                end

                if (-u(1,k-1) + u(2, k-1) ~= 0)
                    dydv.pH = pH / (-u(1,k-1) + u(2, k-1));
                else
                    dydv.pH = 1;
                end

                for i = 1:2:size(obj.M_matrix, 1)
                    M_new(i, :)   = dydv.h  * obj.M_matrix(i, :);
                    M_new(i+1, :) = dydv.pH * obj.M_matrix(i+1, :);
                end
                K_new = (M_new' * M_new + I)^(-1) * M_new';
                for i = 1:2
                    for j = 1:2
                        ke_new(i,j) = sum(K_new(i, j:2:end));
                    end
                end
        
                for i = 1:2:size(obj.Mp_matrix, 1)
                    Mp_new(i, :)   = dydv.h  * obj.Mp_matrix(i, :);
                    Mp_new(i+1, :) = dydv.pH * obj.Mp_matrix(i+1, :);
                end
                ku_new = K_new(1:2, :) * Mp_new;
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk', delta_up(1:end-2)];

                % Obliczenie uchybu    
                e = [y_zad(1, k) - y(1, k);
                    y_zad(2, k) - y(2, k - 3)];
            
                % Obliczenie przyrostu sterowania dla chwili (i+1) w chwili i-tej
                delta_uk = obj.ke * e - obj.ku * delta_up';

                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
        
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;      
        end

        function [y, u, E, E_u, E_y] = dmc_nplWiener(obj, y_zad, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obiekt, fis, type)
            %% Alokacja pamięci
            u = zeros(2, obiekt.kk);
            delta_u = zeros(2, obiekt.kk);
            
            %% Sterowanie DMC
            [v_h.Q1, v_h.Q3, v_Wa4.Q1, v_Wa4.Q3, v_Wb4.Q1, v_Wb4.Q3] = deal(zeros(1, obiekt.kk));
            y = zeros(2, obiekt.kk);

            I = eye(obj.Nu*2) * obj.lambda;
        
            for k = obiekt.delay+3:obiekt.kk
                v_h.Q1(k) = - a_h*v_h.Q1(k-1) + b_h*u(1, k-1);
                v_h.Q3(k) = - a_h*v_h.Q3(k-1) + b_h*u(2, k-1);
                y(1, k) = ((obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_h.Q1(k)+v_h.Q3(k)) / obiekt.C_V).^2 - obiekt.h_0;
                
                v_Wa4.Q1(k) = - a_Wa4*v_Wa4.Q1(k-1) + b_Wa4*u(1, k-1);
                v_Wa4.Q3(k) = - a_Wa4*v_Wa4.Q3(k-1) - b_Wa4*u(2, k-1);
                v_Wb4.Q1(k) = - a_Wb4*v_Wb4.Q1(k-1) + b_Wb4*u(1, k-1);
                v_Wb4.Q3(k) = - a_Wb4*v_Wb4.Q3(k-1) + b_Wb4*u(2, k-1);

                Wa4 = (obiekt.W_a1*(obiekt.Q_10+v_Wa4.Q1(k)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30-v_Wa4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+v_Wa4.Q1(k)-v_Wa4.Q3(k));
                Wb4 = (obiekt.W_b1*(obiekt.Q_10-v_Wb4.Q1(k)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30-v_Wb4.Q3(k)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30-v_Wb4.Q1(k)-v_Wb4.Q3(k));
                y(2, k) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;

                if (strcmp(type, 'linear'))
                    h = evalfis(fis.h, [v_h.Q1(k), v_h.Q3(k)]);
                    Wa4 = evalfis(fis.Wa4, [v_Wa4.Q1(k), v_Wa4.Q3(k)]);
                    Wb4 = evalfis(fis.Wb4, [v_Wb4.Q1(k), v_Wb4.Q3(k)]);
                else
                    h = evalfis(fis.h, [sinh(v_h.Q1(k)/15), sinh(v_h.Q3(k)/15)]);
                    Wa4 = evalfis(fis.Wa4, [tanh(v_Wa4.Q1(k)/15) tanh(v_Wa4.Q3(k)/15)]);
                    Wb4 = evalfis(fis.Wb4, [sinh(v_Wa4.Q1(k)/15) sinh(v_Wa4.Q3(k)/15)]);
                end

                pH = obiekt.pH_calc(Wa4 + obiekt.W_a40, Wb4 + obiekt.W_b40) - obiekt.pH_0;

                if (u(1,k-1) + u(2, k-1) ~= 0)
                    dydv.h = h / (u(1,k-1) + u(2, k-1));
                else
                    dydv.h = 1;
                end

                if (-u(1,k-1) + u(2, k-1) ~= 0)
                    dydv.pH = pH / (-u(1,k-1) + u(2, k-1));
                else
                    dydv.pH = 1;
                end

                for i = 1:2:size(obj.M_matrix, 1)
                    M_new(i, :)   = dydv.h  * obj.M_matrix(i, :);
                    M_new(i+1, :) = dydv.pH * obj.M_matrix(i+1, :);
                end
                K_new = (M_new' * M_new + I)^(-1) * M_new';
       
                Y_0 = fuzzy_free_response(u, v_h, v_Wa4, v_Wb4, y, k, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, obj.N, fis, type);
                Y_0_mod = [Y_0(:,1), [Y_0(3:end,2); Y_0(end,2); Y_0(end,2)]];
                Y_zad = y_zad(:, k)' .* ones(obj.N, 1);
                e = (Y_zad - Y_0_mod)'; 
                e_vec = e(:);  
                delta_uk = K_new(1:2,:) * e_vec;
        
                % Ograniczenie wartości przyrostu sterowania
                delta_uk(1) = min(max(delta_uk(1), -obj.delta_uk_max), obj.delta_uk_max);
                delta_uk(2) = min(max(delta_uk(2), -obj.delta_uk_max), obj.delta_uk_max);
                delta_u(1, k) = delta_uk(1);
                delta_u(2, k) = delta_uk(2);
        
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk(1);
                u(2, k) = u(2, k-1) + delta_uk(2);
                
                % Ograniczenie sterowania
                u(1, k) = max(min(u(1, k), obj.u_max), -obj.u_max);
                u(2, k) = max(min(u(2, k), obj.u_max), -obj.u_max);
            end
        
            E_u = obj.lambda * sum(sum(delta_u.^2)) / obiekt.kk;
            E_y = sum(sum((y_zad - y).^2)) / obiekt.kk;         
            E = E_u + E_y;
        
            function y_0 = fuzzy_free_response(u, v_h, v_Wa4, v_Wb4, y, k, a_h, b_h, a_Wa4, b_Wa4, a_Wb4, b_Wb4, N, fis, type)
                y_0 = zeros(N, 2);
                [v_0.h_Q1, v_0.h_Q3, v_0.Wa4_Q1, v_0.Wa4_Q3, v_0.Wb4_Q1, v_0.Wb4_Q3] = deal(zeros(1, N));
                u_10 = u(1, k-1);
                u_20 = u(2, k-1);
        
                if (strcmp(type, 'linear'))
                    y_hat.h = evalfis(fis.h, [v_h.Q1(k), v_h.Q3(k)]);
                    y_hat.Wa4 = evalfis(fis.Wa4, [v_Wa4.Q1(k), v_Wa4.Q3(k)]);
                    y_hat.Wb4 = evalfis(fis.Wb4, [v_Wb4.Q1(k), v_Wb4.Q3(k)]);
                else
                    y_hat.h = evalfis(fis.h, [sinh(v_h.Q1(k)/15), sinh(v_h.Q3(k)/15)]);
                    y_hat.Wa4 = evalfis(fis.Wa4, [tanh(v_Wa4.Q1(k)/15), tanh(v_Wa4.Q3(k)/15)]);
                    y_hat.Wb4 = evalfis(fis.Wb4, [sinh(v_Wb4.Q1(k)/15), sinh(v_Wb4.Q3(k)/15)]);
                end

                y_hat.pH = obiekt.pH_calc(y_hat.Wa4 + obiekt.W_a40, y_hat.Wb4 + obiekt.W_b40) - obiekt.pH_0;

                dk.h = y(1, k) - y_hat.h;
                dk.pH = y(2, k) - y_hat.pH;
        
                for j = 1:N
                    if j == 1
                        v_0.h_Q1(j) = -a_h*v_h.Q1(k) + b_h*u_10;
                        v_0.h_Q3(j) = -a_h*v_h.Q3(k) + b_h*u_20;

                        v_0.Wa4_Q1(j) = - a_Wa4*v_Wa4.Q1(k) + b_Wa4*u_10;
                        v_0.Wa4_Q3(j) = - a_Wa4*v_Wa4.Q3(k) - b_Wa4*u_20;
                        v_0.Wb4_Q1(j) = - a_Wb4*v_Wb4.Q1(k) + b_Wb4*u_10;
                        v_0.Wb4_Q3(j) = - a_Wb4*v_Wb4.Q3(k) + b_Wb4*u_20;
                    else
                        v_0.h_Q1(j) = -a_h*v_0.h_Q1(j-1) + b_h*u_10;
                        v_0.h_Q3(j) = -a_h*v_0.h_Q3(j-1) + b_h*u_20;

                        v_0.Wa4_Q1(j) = - a_Wa4*v_0.Wa4_Q1(j-1) + b_Wa4*u_10;
                        v_0.Wa4_Q3(j) = - a_Wa4*v_0.Wa4_Q3(j-1) - b_Wa4*u_20;
                        v_0.Wb4_Q1(j) = - a_Wb4*v_0.Wb4_Q1(j-1) + b_Wb4*u_10;
                        v_0.Wb4_Q3(j) = - a_Wb4*v_0.Wb4_Q3(j-1) + b_Wb4*u_20;
                    end
                end
        
                for j = 1:N
                    if (strcmp(type, 'linear'))
                        y_0(j, 1) = evalfis(fis.h, [v_0.h_Q1(j), v_0.h_Q3(j)]) + dk.h;
                        wa4 = evalfis(fis.Wa4, [v_0.Wa4_Q1(j), v_0.Wa4_Q3(j)]);
                        wb4 = evalfis(fis.Wb4, [v_0.Wb4_Q1(j), v_0.Wb4_Q3(j)]);
                        ph = obiekt.pH_calc(wa4 + obiekt.W_a40, wb4 + obiekt.W_b40) - obiekt.pH_0;
                        y_0(j, 2) = ph + dk.pH;
                    else
                        y_0(j, 1) = evalfis(fis.h, [sinh(v_0.h_Q1(j)/15), sinh(v_0.h_Q3(j)/15)]) + dk.h;
                        wa4 = evalfis(fis.Wa4, [tanh(v_0.Wa4_Q1(j)/15), tanh(v_0.Wa4_Q3(j)/15)]);
                        wb4 = evalfis(fis.Wb4, [sinh(v_0.Wb4_Q1(j)/15), sinh(v_0.Wb4_Q3(j)/15)]);
                        ph = obiekt.pH_calc(wa4 + obiekt.W_a40, wb4 + obiekt.W_b40) - obiekt.pH_0;
                        y_0(j, 2) = ph + dk.pH;
                    end
                end
            end
        end
        
        function show_result(~, y, y_zad, u, E, E_u, E_y, kk, s, t)
            fprintf("Błąd DMC-%s (%s) \t E_u: %.3f \n", s, t, E_u);
            fprintf("Błąd DMC-%s (%s) \t E_y: %.3f \n", s, t, E_y);
            fprintf("Błąd DMC-%s (%s) \t E = %.3f \n\n", s, t, E);

            figure;
            subplot(2,2,1);
            stairs(0:kk-1, y(1,:), 'b-', 'LineWidth', 0.8);
            hold on;
            stairs(0:kk-1, y_zad(1,:), 'r-', 'LineWidth', 0.8);
            hold off;
            legend('y', 'y_{zad}', 'Location', 'best');
            title(sprintf('Sygnał wyjściowy y(k) \t DMC - %s \t %s', s, t));
            xlabel('k');
            ylabel('h(k)');
            grid on;
            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/y_%s%s.png', s, t));  % Zapisuje jako plik PNG
            
            subplot(2,2,2);
            stairs(0:kk-1, y(2,:), 'b-', 'LineWidth', 0.8);
            hold on;
            stairs(0:kk-1, y_zad(2,:), 'r-', 'LineWidth', 0.8);
            hold off;
            legend('y', 'y_{zad}', 'Location', 'best');
            title(sprintf('Sygnał wyjściowy y(k) \t DMC - %s \t %s', s, t));
            xlabel('k');
            ylabel('pH(k)');
            grid on;

            subplot(2,2,3);
            stairs(0:kk-1, u(1,:), 'b-', 'LineWidth', 0.8);
            legend('u', 'Location', 'best');
            title(sprintf('Sygnał sterujący Q_1(k) \t DMC - %s \t %s', s, t));
            xlabel('k');
            ylabel('Q_1(k)');
            grid on;
            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/u_%s%s.png', s, t));  % Zapisuje jako plik PNG
            
            subplot(2,2,4);
            stairs(0:kk-1, u(2,:), 'b-', 'LineWidth', 0.8);
            legend('u', 'Location', 'best');
            title(sprintf('Sygnał sterujący Q_3(k) \t DMC - %s \t %s', s, t));
            xlabel('k');
            ylabel('Q_3(k)');
            grid on;
        end

    end
end