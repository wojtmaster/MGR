classdef Hammerstein < handle

    properties
        U_min = -15;
        U_max = 15;
        Q1_grid
        Q3_grid
        h
        pH

        linear_fis
        nonlinear_fis
    end

    methods
        function obj = Hammerstein(modifiedEuler)
            U = [linspace(obj.U_min, obj.U_max, 100);
                linspace(obj.U_min, obj.U_max, 100)];
            [obj.Q1_grid, obj.Q3_grid] = meshgrid(U(1,:), U(2,:));  % kombinacje

            obj.h = zeros(100,100);
            obj.pH = zeros(100,100);
            
            % Petla po siatce sterowań
            for i = 1:length(U)
                for j = 1:length(U)
                    u = [ones(1, 200)*U(1,i);
                         zeros(1, 200);
                         ones(1, 200)*U(2,j)];
                
                    [y, ~, ~] = modifiedEuler(u, 200);
                    obj.h(i,j) =  y(1, end);
                    obj.pH(i,j) = y(2, end); 
                end
            end
        end

        function linearFuzzy(obj)
            % --------------- LINEAR H --------------- %
            U_center = linspace(obj.U_min, obj.U_max, 4);
            obj.linear_fis.h = sugfis('Name', 'Hammerstein', 'Type', 'sugeno');
            obj.linear_fis.h = addInput(obj.linear_fis.h, [obj.U_min obj.U_max], 'Name', 'Q1');
            obj.linear_fis.h = addInput(obj.linear_fis.h, [obj.U_min obj.U_max], 'Name', 'Q3');
            
            % Definiowanie funkcji przynależności (gaussmf)
            for i = 1:length(U_center)
                obj.linear_fis.h = addMF(obj.linear_fis.h, 'Q1', 'gaussmf', [5.5, U_center(i)]);
                obj.linear_fis.h = addMF(obj.linear_fis.h, 'Q3', 'gaussmf', [5.5, U_center(i)]);
            end
            
            % Definiowanie wyjścia i początkowych następników (a_i * u + b_i)
            obj.linear_fis.h = addOutput(obj.linear_fis.h, [-14 38], 'Name', 'h_fuzzy');
            
            % Współczynniki (a_i, b_i) następników
            a_param = [	0.5337	0.7375	1.0039	1.2568	0.8414	0.7312	1.0625	1.0320	0.8931	0.7580	0.9163	0.8556	0.9909	0.8487	1.0066	1.1814];
            b_param = [	0.5538	0.6757	0.9707	1.0484	0.6007	0.9617	0.7649	0.7389	0.9079	0.8513	0.8576	0.9957	1.0739	1.1139	1.0994	1.2348];
            c_param = [	3.9600	2.8730	3.8968	2.3340	2.4851	0.5095	-0.4606	2.8605	1.5962	-0.4077	0.0377	3.4624	1.1485	2.4451	2.0397	2.8176];
            
            % Dodanie reguł TS w postaci liniowej
            for i = 1:16
                obj.linear_fis.h = addMF(obj.linear_fis.h, 'h_fuzzy', 'linear', [a_param(i), b_param(i), c_param(i)]);
            end
            
            % Reguły Takagi-Sugeno: [inputMF, outputMF, weight]
            ruleList = [];
            iter = 1;
            for i = 1:length(U_center)
                for j = 1:length(U_center)
                    ruleList(end+1, :) = [i, j, iter, 1, 1];
                    iter = iter + 1;
                end
            end
            
            % Dodanie reguł do systemu
            obj.linear_fis.h = addRule(obj.linear_fis.h, ruleList);

            % --------------- LINEAR PH --------------- %
            obj.linear_fis.pH = readfis("D:\EiTI\MGR\reaktor_pH\hammerstein_linearFIS_pH.fis");
            % X = [obj.Q1_grid(:) obj.Q3_grid(:)];
            % Y = obj.pH(:);
            % % Generowanie systemu rozmytego
            % fis = genfis1([X Y], 15, 'gaussmf', 'linear');
            % % Trening ANFIS
            % options = anfisOptions('InitialFIS', fis, 'EpochNumber', 100, ...
            %     'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            % obj.linear_fis.pH= anfis([X Y], options);
        end

        function nonlinearFuzzy(obj)
            % --------------- NONLINEAR H --------------- %
            obj.nonlinear_fis.h.U_center = linspace(obj.U_min, obj.U_max, 2);
            obj.nonlinear_fis.h.sigma = 18;
            obj.nonlinear_fis.h.rules_number = 4;

            % Początkowe współczynniki (a_i, b_i)
            obj.nonlinear_fis.h.a_param = [-1.4078 0.4264 1.4457 3.1947];
            obj.nonlinear_fis.h.b_param = [-1.4918 1.3244 0.3397 3.1298];
            obj.nonlinear_fis.h.c_param = [-26.0016	-5.4701	-6.3689	38.7067];
        
            % --------------- NONLINEAR PH --------------- %
            % obj.nonlinear_fis.pH.U_center = linspace(obj.U_min, obj.U_max, 8);
            % obj.nonlinear_fis.pH.sigma = 2.5;
            % obj.nonlinear_fis.pH.rules_number = 8;
            % 
            % obj.nonlinear_fis.pH.a_param = [-4.0181	-3.3509	-2.9058	-3.3916	0.1152	-4.3212	-3.7344	-4.6015];
            % obj.nonlinear_fis.pH.b_param = [0.0525	0.3775	0.2622	0.0554	0.1653	0.3265	0.1444	0.4012];

            X = [tanh((obj.Q1_grid(:) - obj.Q3_grid(:))/15)];
            Y = obj.pH(:);
            % Generowanie systemu rozmytego
            fis = genfis1([X Y], 5, 'gaussmf', 'linear');
            % Trening ANFIS
            options = anfisOptions('InitialFIS', fis, 'EpochNumber', 100, ...
                'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            obj.nonlinear_fis.pH = anfis([X Y], options);
        end

        function testLinearModel(obj, U, a_h, a_pH, b_h, b_pH, obiekt, type, index)
            [Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk);
            t = 0:obiekt.Tp:(obiekt.kk-1)*obiekt.Tp; 
            Y_out = zeros(1, obiekt.kk);
            
            % --------------- LINEAR H --------------- %
            if(strcmp(type, 'h'))
                Y_fuzzy = evalfis(obj.linear_fis.h, [U(1,:)', U(3,:)']);
                for k = 2:obiekt.kk
                    if(U(1,k-1) + U(3, k-1) ~= 0)
                        K = Y_fuzzy(k-1) / (U(1, k-1) + U(3, k-1));
                    else
                        K = 1;
                    end
                    Y_out(k) = - a_h.Q1*Y_out(k-1) + K*b_h.Q1*U(1, k-1) + b_h.Q2*U(2, k-1) + K*b_h.Q3*U(3, k-1);
                end

                E_lin = sum((Y_real(1, :) - Y_lin(1, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(1, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(1, :), 'b', t, Y_lin(1, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('h [cm]');
                xlabel('t [s]');
                grid on;

            % --------------- LINEAR PH --------------- %
            else
                Y_fuzzy = evalfis(obj.linear_fis.pH, [U(1,:)', U(3,:)']);
                % Y_fuzzy = net([U(1,:)', U(3,:)']');

                y_1 = zeros(1,obiekt.kk);
                y_2 = zeros(1,obiekt.kk);
                y_3 = zeros(1,obiekt.kk);

                for k = 4:obiekt.kk
                    
                    if(abs(U(1,k-1) + U(3, k-1)) ~= 0 )
                        K = abs(Y_fuzzy(k-1)) / (abs(U(1,k-1)) + abs(U(3,k-1)));
                    else
                        K = 1;
                    end

                    y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + K*b_pH.Q1*U(1,k-1);
                    y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + b_pH.Q2*U(2,k-1);
                    y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-3)' + K*b_pH.Q3*U(3,k-1);
                    Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                    % Y_out(k) = -A * Y_out(k-1:-1:k-5)' + K*B_Q1*U(1,k-1:-1:k-4)' + B_Q2*U(2,k-1:-1:k-4)' + K*B_Q3*U(3,k-1:-1:k-3)';
                    % disp(K);
                    % if (mod(k, 100) == 0)
                    %     fprintf("%d. %.3f %.3f \n", k, K, K_Q3);
                    % end
                end

                E_lin = sum((Y_real(2, :) - Y_lin(2, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(2, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(2, :), 'b', t, Y_lin(2, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);

                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');

                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('pH');
                xlabel('t [s]');
                grid on;
            end

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/HammersteinLinearModel_%d.png', index));  % Zapisuje jako plik PNG
        end

        function testNonlinearModel(obj, U, a_h, a_pH, b_h, b_pH, obiekt, type, index)
            gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
            
            [Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk); % Symulacja rzeczywistego układu
            t = 0:obiekt.Tp:(obiekt.kk-1)*obiekt.Tp;

            Y_out = zeros(1,obiekt.kk);
            Y_fuzzy = zeros(1,obiekt.kk);

            % --------------- NONLINEAR H --------------- %
            if(strcmp(type, 'h'))
                for k = 1:obiekt.kk
                    for i = 1:sqrt(obj.nonlinear_fis.h.rules_number)
                        deg_u1(i) = [gaussmf_val(U(1,k), obj.nonlinear_fis.h.sigma, obj.nonlinear_fis.h.U_center(i))];
                        deg_u2(i) = [gaussmf_val(U(3,k), obj.nonlinear_fis.h.sigma, obj.nonlinear_fis.h.U_center(i))];
                    end
                
                    iter = 1;
                    for i = 1:sqrt(obj.nonlinear_fis.h.rules_number)
                        for j = 1:sqrt(obj.nonlinear_fis.h.rules_number)
                            degrees_all(iter) = deg_u1(i) * deg_u2(j);
                            iter = iter + 1;
                        end
                    end

                    w = 0;
                    output = 0;
                    for i = 1:obj.nonlinear_fis.h.rules_number
                        output = output + degrees_all(i)*(obj.nonlinear_fis.h.a_param(i)*sinh(U(1,k)/7.5) + ...
                        obj.nonlinear_fis.h.b_param(i)*sinh(U(3,k)/7.5) + obj.nonlinear_fis.h.c_param(i));
                        w = w + degrees_all(i);
                    end
                    Y_fuzzy(k) = output / w;
                end

                for k = 2:obiekt.kk
                    if(U(1,k-1) + U(3, k-1) ~= 0)
                        K = Y_fuzzy(k-1) / (U(1, k-1) + U(3, k-1));
                    else
                        K = 1;
                    end
                    Y_out(k) = - a_h.Q1*Y_out(k-1) + K*b_h.Q1*U(1, k-1) + K*b_h.Q2*U(2, k-1) + K*b_h.Q3*U(3, k-1);
                end

                E_lin = sum((Y_real(1, :) - Y_lin(1, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(1, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN NONLINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(1, :), 'b', t, Y_lin(1, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('h [cm]');
                xlabel('t [s]');
                grid on;

            % --------------- NONLINEAR PH --------------- %
            else
                % y_1 = zeros(1,obiekt.kk);
                % y_2 = zeros(1,obiekt.kk);
                % y_3 = zeros(1,obiekt.kk);
                % 
                % for k = 1:obiekt.kk
                %     for i = 1:obj.nonlinear_fis.pH.rules_number
                %         deg(i) = gaussmf_val((U(1,k) - U(3,k)), obj.nonlinear_fis.pH.sigma, obj.nonlinear_fis.pH.U_center(i));            
                %     end
                % 
                %     output = 0;
                %     w = 0;
                %     for i = 1:obj.nonlinear_fis.pH.rules_number
                %         output = output + deg(i)*(obj.nonlinear_fis.pH.a_param(i)*tanh((U(1,k) - U(3,k))/2) + obj.nonlinear_fis.pH.b_param(i));
                %         w = w + deg(i);
                %     end
                %     Y_fuzzy(k) = output / w;
                % end
                % 
                % for k = 4:obiekt.kk
                %     if(U(1,k-1) + U(3,k-1) ~= 0)
                %         K_Q1 = Y_fuzzy(k-1) / (2*U(1,k-1));
                %         K_Q2 = 1;
                %         K_Q3 = Y_fuzzy(k-1) / (2*U(3,k-1));
                %         K = Y_fuzzy(k-1) / (U(1, k-1) + U(3,k-1));
                %     else
                %         K_Q1 = 1;
                %         K_Q2 = 1;
                %         K_Q3 = 1;
                %         K = 1;
                %     end
                % 
                %     y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + K*b_pH.Q1*U(1,k-1);
                %     y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + b_pH.Q2*U(2,k-1);
                %     y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-3)' + K*b_pH.Q3*U(3,k-1);
                %     Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                % end

                Y_fuzzy = evalfis(obj.nonlinear_fis.pH, tanh((U(1,:)'- U(3,:)')/15));
                % Y_fuzzy = net([U(1,:)', U(3,:)']');

                y_1 = zeros(1,obiekt.kk);
                y_2 = zeros(1,obiekt.kk);
                y_3 = zeros(1,obiekt.kk);

                for k = 4:obiekt.kk

                    % w = zeros(1, length(obj.nonlinear_fis.pH.Rules));
                    % for i = 1:length(obj.nonlinear_fis.pH.Rules)
                    %     w(i) = evalmf(obj.nonlinear_fis.pH.Inputs.MembershipFunctions(i), tanh((U(1,k-1)- U(3,k-1))/15));  % Aktywacja i-tej reguły
                    % end
                    % 
                    % % Obliczenie pochodnych
                    % dydQ1 = 0;
                    % dydQ3 = 0;
                    % for i = 1:length(obj.nonlinear_fis.pH.Rules)
                    %     a_i = obj.nonlinear_fis.pH.Outputs.MembershipFunctions(i).Parameters(1);
                    %     derivative = (a_i / 15) * (1 - tanh((U(1,k-1)- U(3,k-1))/15)^2);
                    % 
                    %     dydQ1 = dydQ1 + w(i) * derivative;
                    %     dydQ3 = dydQ3 + w(i) * (-derivative);  % Pochodna po Q3 ma przeciwny znak
                    % end

                    delta = 0.1;
                    y0 = evalfis(obj.nonlinear_fis.pH, tanh((U(1,k-1)- U(3,k-1))/15));
                    y_Q1 = evalfis(obj.nonlinear_fis.pH, tanh(((U(1,k-1) + delta) - U(3,k-1))/15));
                    y_Q3 = evalfis(obj.nonlinear_fis.pH, tanh((U(1,k-1) - (U(3,k-1)+delta))/15));
                    
                    dydQ1 = (y_Q1 - y0) / delta;
                    dydQ3 = (y_Q3 - y0) / delta;

                    if (k == 20)
                        return;
                        e
                    
                    if(abs(Y_fuzzy(k-1)) <= 3)
                        K = Y_fuzzy(k-1) / (abs(U(1,k-1)) + abs(U(3,k-1)));
                        K_Q1 = Y_fuzzy(k-1) / U(1, k-1);
                        K_Q3 = Y_fuzzy(k-1) / U(3, k-1);
                    else
                        K = 0;
                        K_Q1 = 1;
                        K_Q3 = 1;
                    end

                    K = sqrt(dydQ1^2 + dydQ3^2);

                    y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + dydQ1*b_pH.Q1*U(1,k-1);
                    y_2(k) = 0;
                    y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-3)' + dydQ3*b_pH.Q3*U(3,k-1);
                    Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                    % Y_out(k) = -A * Y_out(k-1:-1:k-5)' + K*B_Q1*U(1,k-1:-1:k-4)' + B_Q2*U(2,k-1:-1:k-4)' + K*B_Q3*U(3,k-1:-1:k-3)';
                    % disp(K);
                    % if (mod(k, 100) == 0)
                    %     fprintf("%d. %.3f %.3f \n", k, K, K_Q3);
                    % end
                end

                E_lin = sum((Y_real(2, :) - Y_lin(2, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(2, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN NONLINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(2, :), 'b', t, Y_lin(2, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('pH');
                xlabel('t [s]');
                grid on;

            end

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/HammersteinNonlinearModel_%d.png', index));  % Zapisuje jako plik PNG
        end

        function show_fuzzy(~, fis, s)
            figure;
            plotmf(fis, 'input', 1);
            title(sprintf('Funkcje przynależności dla u(k) - następniki %s', s));
            xlabel('u');
            ylabel('$\mu(u)$', 'Interpreter', 'latex');
            grid on;

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/HammersteinfuzzySets_%s.png', s));  % Zapisuje jako plik PNG
        end
    end
end