%% LINEAR HAMMERSTEIN MODEL
clear;
obiekt = Obiekt();
%  pH_0, h_0, Q_10, Q_20, Q_30
obiekt.linearization(16.6, 0.55, 15.6);

%% Dane do wykresów 3D
% Zakresy sterowania
U_min = -15;
U_max = 15;
U = [linspace(U_min, U_max, 100);
    linspace(U_min, U_max, 100)];

[Q1_grid, Q3_grid] = meshgrid(U(1,:), U(2,:));  % kombinacje

% load pH_data.mat;
% load h_data.mat;

%% Przygotuj siatkę
h = zeros(100,100);
pH = zeros(100,100);

% Petla po siatce sterowań
for i = 1:length(U)
    for j = 1:length(U)
        u = [ones(1, 200)*U(1,i);
             zeros(1, 200);
             ones(1, 200)*U(2,j)];
    
        [y, ~, ~] = obiekt.modifiedEuler(u, 200);
        h(i,j) =  y(1, end);
        pH(i,j) = y(2, end); 
    end
end

% Rysuj 3D wykres
figure;
surf(Q1_grid, Q3_grid, pH);
xlabel('Q_1 [ml/s]');
ylabel('Q_3 [ml/s]');
zlabel('pH');
title('Wpływ dopływów Q_1 oraz Q_3 na stężenie substancji pH');
shading interp;
colorbar;
% saveas(gcf, 'D:/EiTI/MGR/raporty/raport_MGR/pictures/ph-_staticCharacteristic.png');  % Zapisuje jako plik PNG

figure;
surf(Q1_grid, Q3_grid, h);
xlabel('Q_1 [ml/s]');
ylabel('Q_3 [ml/s]');
zlabel('h [cm]');
title('Wpływ dopływów Q_1 oraz Q_3 na wysokość słupa cieczy h');
shading interp;
colorbar;
% saveas(gcf, 'D:/EiTI/MGR/raporty/raport_MGR/pictures/h_staticCharacteristic.png');  % Zapisuje jako plik PNG

%% ANFIS
% Dane wejściowe
% X = [Q1_grid(:)  Q3_grid(:)];
X = [tanh((Q1_grid(:)/15) - tanh(Q3_grid(:))/15)];
Y = pH(:);
data_train = [X Y];

% Ustawienia
numMFs = 15;                 % liczba funkcji przynależności na wejście
mfType = 'gaussmf';         % typ MF: gaussmf, gbellmf, trimf, ...

% Generowanie systemu rozmytego
fis = genfis1(data_train, numMFs, mfType, 'linear');
% fis = genfis2(X, Y, 0.1);

% Trening ANFIS
options = anfisOptions('InitialFIS', fis, 'EpochNumber', 100, ...
    'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
fis_trained_hiperbolic = anfis(data_train, options);

% Predykcja
Y_pred = evalfis(fis_trained_hiperbolic, X);
pH_pred = reshape(Y_pred, size(Q1_grid));

% Rysunek
figure;
surf(Q1_grid, Q3_grid, pH_pred);
xlabel('Q_1'); ylabel('Q_3'); zlabel('pH');
title('Dokładniejsza charakterystyka statyczna TS (genfis1 + ANFIS)');
shading interp; colormap turbo;

%% Tworzenie początkowego systemu rozmytego TS
close all;
fis = sugfis('Name', 'Hammerstein', 'Type', 'sugeno');
rules_number = 16;
U_center = linspace(U_min, U_max, sqrt(rules_number));
sigma = ones(1, sqrt(rules_number)) * 5;

fis = addInput(fis, [U_min U_max], 'Name', 'Q1');
fis = addInput(fis, [U_min U_max], 'Name', 'Q3');

% Definiowanie funkcji przynależności (gaussmf)
for i = 1:length(U_center) 
    fis = addMF(fis, 'Q1', 'gaussmf', [sigma(i), U_center(i)]);
    fis = addMF(fis, 'Q3', 'gaussmf', [sigma(i), U_center(i)]);
end

% plotmf(fis, 'input', 1);

% Definiowanie wyjścia i początkowych następników (a_i * u + b_i)
fis = addOutput(fis, [U_min U_max], 'Name', 'Q_fuzzy');

% Początkowe współczynniki (a_i, b_i, c_i)
a_param = ones(1,rules_number)*0.001;
b_param = ones(1,rules_number)*0.25;
c_param = ones(1,rules_number)*0.2;

% % For h
% a_param = [	0.5337	0.7375	1.0039	1.2568	0.8414	0.7312	1.0625	1.0320	0.8931	0.7580	0.9163	0.8556	0.9909	0.8487	1.0066	1.1814];
% b_param = [	0.5538	0.6757	0.9707	1.0484	0.6007	0.9617	0.7649	0.7389	0.9079	0.8513	0.8576	0.9957	1.0739	1.1139	1.0994	1.2348];
% c_param = [	3.9600	2.8730	3.8968	2.3340	2.4851	0.5095	-0.4606	2.8605	1.5962	-0.4077	0.0377	3.4624	1.1485	2.4451	2.0397	2.8176];

% % For pH
% a_param = [0.0076	0.0111	0.0146	0.0071	0.0084	0.0051	0.0104	0.0085	0.0149	0.0184	0.0096	0.0031	0.0091	0.0131	0.0099	0.0057];
% b_param = [0.4562	0.1628	0.2621	0.2383	0.2939	0.3986	0.2130	0.1915	0.2072	0.3652	0.2975	0.2622	0.4104	0.3818	0.3222	0.2677];
% c_param = [10.9998	12.9682	9.1010	8.9379	7.7478	9.8031	12.0307	10.8059	6.1809	3.6940	4.4275	4.7971	6.3172	5.5293	0.7273	5.0499];

% Dodanie reguł TS w postaci liniowej
for i = 1:rules_number
    fis = addMF(fis, 'Q_fuzzy', 'linear', [a_param(i), b_param(i), c_param(i)]);
end

% Reguły Takagi-Sugeno: [inputMF, outputMF, weight]
ruleList = [];
iter = 1;
for i = 1:sqrt(rules_number)
    for j = 1:sqrt(rules_number)
        ruleList(end+1, :) = [i, j, iter, 1, 1];
        iter = iter + 1;
    end
end

fis = addRule(fis, ruleList);

% % Optymalizacja przy pomocy fminsearch
initial_params = [a_param, b_param c_param];  % Początkowe wartości a_param i b_param
options = optimset('Display', 'iter', 'MaxFunEvals', 4000, 'MaxIter', 2000); % Opcje optymalizacji
optimal_params = fminsearch(@(params) linearCoeff(params, U_center, U, h, rules_number, sigma), initial_params, options);

% Po optymalizacji
a_optimal = optimal_params(1:rules_number);
b_optimal = optimal_params(rules_number+1:2*rules_number);
c_optimal = optimal_params(2*rules_number+1:end);
% a_optimal = a_param;
% b_optimal = b_param;
% c_optimal = c_param;

% Wyświetlanie wyników optymalizacji
fprintf('a_param = [');
fprintf("\t%.4f", a_optimal);
fprintf('];\n');
fprintf('b_param = [');
fprintf("\t%.4f", b_optimal);
fprintf('];\n');
fprintf('c_param = [');
fprintf("\t%.4f", c_optimal);
fprintf('];\n');

%% GA
rules_number = 25;
nvars = 3 * rules_number;
U_center = linspace(U_min, U_max, sqrt(rules_number));
sigma = ones(1, sqrt(rules_number)) * 5;

% Zakresy graniczne (opcjonalnie, dopasuj do zakresu działania modelu)
lb = [ones(1, rules_number)*(-1)      ... % a_param ≥ 0
      ones(1, rules_number)*(-1)      ... % b_param ≥ 0
      ones(1, rules_number)*(-15)];      % c_param (bias) – może być ujemny

ub = [ones(1, rules_number)*1    ... % a_param
      ones(1, rules_number)*1    ... % b_param
      ones(1, rules_number)*15];      % c_param

% Definicja funkcji celu (loss function)
fitnessFcn = @(params) Coeff(params, U_center, U, pH, rules_number, sigma);

% Opcje algorytmu genetycznego
opts = optimoptions('ga', ...
    'Display', 'iter', ...
    'MaxGenerations', 1000, ...
    'PopulationSize', nvars*10, ...
    'UseParallel', true, ...
    'PlotFcn', {@gaplotbestf}); % Włącza wykres błędu

% Wywołanie algorytmu genetycznego
[optimal_params, fval] = ga(fitnessFcn, nvars, [], [], [], [], lb, ub, [], opts);

% Początkowe współczynniki (a_i, b_i, c_i)
a_param = ones(1,rules_number)*0.001;
b_param = ones(1,rules_number)*0.25;
c_param = ones(1,rules_number)*0.2;

% Po optymalizacji
a_optimal = optimal_params(1:rules_number);
b_optimal = optimal_params(rules_number+1:2*rules_number);
c_optimal = optimal_params(2*rules_number+1:end);

% Wyświetlanie wyników optymalizacji
fprintf('a_param = [');
fprintf("\t%.4f", a_optimal);
fprintf('];\n');
fprintf('b_param = [');
fprintf("\t%.4f", b_optimal);
fprintf('];\n');
fprintf('c_param = [');
fprintf("\t%.4f", c_optimal);
fprintf('];\n');

%%
% Dane wejściowe (100x100 siatka → przekształć na 10000x2)
input_data = [Q1_grid(:), Q3_grid(:)];  % u1, u2 (każdy punkt z siatki)
output_data = pH(:);                    % odpowiadające pH (1D wektor)

opt = genfisOptions('GridPartition');   % lub 'SubtractiveClustering'
opt.InputMembershipFunctionType = 'gaussmf';  % dobre do lokalnych zmian
opt.NumMembershipFunctions = 5;         % lub więcej, jeśli masz dużo danych
opt.OutputMembershipFunctionType = 'linear';  % TS system = Sugeno 1. rzędu

opt = genfisOptions('SubtractiveClustering');
opt.ClusterInfluenceRange = 0.25;  % im mniejsze, tym więcej reguł
fis = genfis(input_data, output_data, opt);

[x, y] = meshgrid(-15:1:15, -15:1:15);
xy = [x(:), y(:)];  % dane wejściowe do evalfis

z = evalfis(fis, xy);        % wynik: wektor 1D
Z = reshape(z, size(x));     % przekształć z powrotem na siatkę

surf(x, y, Z);
xlabel('Q_1'), ylabel('Q_3'), zlabel('pH');

%% Check fuzzy static
% for i = 1:rules_number
%     fis.Outputs.MembershipFunctions(i).Parameters(1) = a_optimal(i);
%     fis.Outputs.MembershipFunctions(i).Parameters(2) = b_optimal(i);
%     fis.Outputs.MembershipFunctions(i).Parameters(3) = c_optimal(i);
% end

Y_out = zeros(size(h));
for i = 1:2:length(U)
    disp(i);
    for j = 1:length(U)
        Y_out(i,j) = evalfis(fis, [U(1,j), U(2,i)]) + obiekt.pH_0;
    end
end

figure;
surf(Q1_grid, Q3_grid, Y_out);
xlabel('Q_3 [ml/s]');
ylabel('Q_1 [ml/s]');
zlabel('pH');
title('Wpływ dopływów Q_1 oraz Q_3 na stężenie substancji pH');
shading interp;
colorbar;
view(135, 0);

%% Identyfikacja dynamiki
% [a_h, b_h, s_h] = obiekt.mse('h');
[a_pH, b_pH, s_pH] = obiekt.mse('pH');

%% Symulacja modelu Hammersteina
% U = [repelem((rand(1, obiekt.kk/300) * 30 - 15), 300);
%     repelem((rand(1, obiekt.kk/700) * 10 - 5), 700);
%     repelem((rand(1, obiekt.kk/300) * 30 - 15), 300)];
U = [repelem((rand(1, obiekt.kk/300) * 30 - 15), 300);
    zeros(1, obiekt.kk);
    repelem((rand(1, obiekt.kk/300) * 30 - 15), 300)];
[Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk);
index = 2;
t = (0:length(U)-1) * obiekt.Tp; % Czas w sekundach (próbkowanie = 20s)

Y_out = zeros(1,obiekt.kk);
Y_fuzzy = zeros(1,obiekt.kk);
y_1 = zeros(1,obiekt.kk);
y_2 = zeros(1,obiekt.kk);
y_3 = zeros(1,obiekt.kk);

Y_out(1:3) = Y_real(index, 1:3);
Y_fuzzy = evalfis(fis, [U(1,:)', U(3,:)']);

for k = 4:obiekt.kk
    % Y_fuzzy(k) = evalfis(fis, [U(1,k), U(3,k)]);
    if(U(1,k-1) + U(3,k-1) ~= 0)
        K = Y_fuzzy(k-1) / (U(1,k-1) + U(3,k-1));
    else
        K = 1;
    end
    K_Q1 = Y_fuzzy(k-1) / (2*U(1,k-1));  % tylko jeśli U(1,k-1) ≠ 0
    K_Q3 = Y_fuzzy(k-1) / (2*U(3,k-1));
    % Y_out(k) = - a_h.Q1*Y_out(k-1) + K*b_h.Q1*U(1, k-1) + K*b_h.Q2*U(2, k-1) + K*b_h.Q3*U(3, k-1);
    y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + K_Q1*b_pH.Q1*U(1,k-1);
    % y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + K*b_pH.Q2*U(2,k-1);
    y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-3)' + K_Q3*b_pH.Q3*U(3,k-1);
    Y_out(k) = y_1(k) + y_3(k);
end

% Wizualizacja wyników
figure;
plot(t, Y_real(index,:), 'b', t, Y_lin(index,:), 'g', t, Y_out, 'r');
legend('Euler', 'Euler liniowy', 'Hammerstein (optymalny TS)', 'Location', 'southwest');
title('Porównanie wyjścia układu rzeczywistego i modelu');
grid on;

E_lin = sum((Y_real(index,:) - Y_lin(index,:)).^2) / obiekt.kk;
E_out = sum((Y_real(index,:) - Y_out).^2) / obiekt.kk;
fprintf("\nE_lin = %.3f\n", E_lin);
fprintf("E_out = %.3f\n", E_out);

%% Losowość
for j = 1:5
    U = [repelem((rand(1, obiekt.kk/400) * 30 - 15), 400);
        zeros(1,obiekt.kk);
        repelem((rand(1, obiekt.kk/400) * 30 - 15), 400)];
    [Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk); % Symulacja rzeczywistego układu
    
    % Symulacja modelu Hammersteina
    U_fuzzy = evalfis(fis, [U(1,:)', U(3,:)']);
    Y_out = zeros(1, obiekt.kk);
    
    for k = 2:obiekt.kk
        Y_out(k) = - a_1*Y_out(k-1) + b_1.Q_1 * U_fuzzy(k-1) + b_1.Q_2 * U(2, k-1) + b_1.Q_3 * U_fuzzy(k-1);
    end
    
    figure;
    plot(t, Y_real(1,:), 'b', t, Y_lin(1,:), 'g', t, Y_out, 'r');
    legend('Eulera', 'Euler liniowy', 'Hammerstein (optymalny TS)');
    title('Porównanie wyjścia układu rzeczywistego i modelu');
    grid on;
    
    E_lin = sum((Y_real(1,:) - Y_lin(1,:)).^2);
    E_out = sum((Y_real(1,:) - Y_out).^2);
    fprintf("\n%d. E_lin = %.3f\n", j, E_lin);
    fprintf("%d. E_out = %.3f\n", j, E_out);
end

%% Funkcja do optymalizacji współczynników
function E_out = linearCoeff(params, U_center, U, Y, rules_number, sigma)
    gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

    % Parametry do optymalizacji
    a_param = params(1:rules_number);
    b_param = params(rules_number+1:2*rules_number);
    c_param = params(2*rules_number+1:end);

    for k = 1:length(U)
        for l = 1:length(U)
            deg_u1 = zeros(1, sqrt(rules_number));
            deg_u2 = zeros(1, sqrt(rules_number));
            for i = 1:sqrt(rules_number)
                deg_u1(i) = gaussmf_val(U(1,l), sigma(i), U_center(i));
                deg_u2(i) = gaussmf_val(U(2,k), sigma(i), U_center(i));
            end

            iter = 1;
            for i = 1:sqrt(rules_number)
                for j = 1:sqrt(rules_number)
                    degrees_all{k, l}(iter) = deg_u1(i) * deg_u2(j);
                    iter = iter + 1;
                end
            end
        end
    end
    
    Y_out = zeros(size(Y));
    E_out = 0;
    % Oblicz odpowiedzi systemu rozmytego dla wszystkich U
    for i = 1:length(U)
        for j = 1:length(U)
            w = 0;
            output = 0;
            for k = 1:rules_number
                output = output + degrees_all{i,j}(k)*(a_param(k)*U(1,j) + b_param(k)*U(2,i) + c_param(k));
                w = w + degrees_all{i,j}(k);
            end
            Y_out(i,j) = output / w;
            E_out = E_out + sum((Y(i,j) - Y_out(i,j))^2);
        end
    end
end

function E_out = Coeff(params, U_center, U, Y, rules_number, sigma)
    n_rules = rules_number;
    n_centers = sqrt(n_rules);

    % Rozbij parametry
    a_param = params(1:n_rules);
    b_param = params(n_rules+1:2*n_rules);
    c_param = params(2*n_rules+1:end);

    % Prealokacja
    n_samples = size(U, 2);
    Y_out = zeros(n_samples, 1);
    E_out = 0;

    % Wartości funkcji przynależności dla każdego wejścia
    deg_u1 = zeros(n_centers, n_samples);
    deg_u2 = zeros(n_centers, n_samples);

    for i = 1:n_centers
        deg_u1(i, :) = exp(-((U(1,:) - U_center(i)).^2) / (2 * sigma(i)^2));
        deg_u2(i, :) = exp(-((U(2,:) - U_center(i)).^2) / (2 * sigma(i)^2));
    end

    % Oblicz wagę reguł i wyjście rozmyte
    for k = 1:n_samples
        weights = zeros(n_rules, 1);
        outputs = zeros(n_rules, 1);
        iter = 1;
        for i = 1:n_centers
            for j = 1:n_centers
                w = deg_u1(i, k) * deg_u2(j, k);
                weights(iter) = w;
                outputs(iter) = w * (a_param(iter)*U(1,k) + b_param(iter)*U(2,k) + c_param(iter));
                iter = iter + 1;
            end
        end

        w_sum = sum(weights);
        if w_sum == 0
            Y_out(k) = 0; % albo jakiś domyślny fallback
        else
            Y_out(k) = sum(outputs) / w_sum;
        end
        E_out = E_out + (Y(k) - Y_out(k))^2;
    end

    E_out = E_out / n_samples;  % MSE
end