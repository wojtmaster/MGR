classdef Wiener < handle
    properties
        Y_h
        Y_pH
        h
        pH
        Y_min = -30;
        Y_max = 30;
        U_min = -15;
        U_max= 15;

        linear_fis
        nonlinear_fis
    end

    methods

        function obj = Wiener(a_h, a_pH, b_h, b_pH, obiekt)
            U = [linspace(obj.U_min, obj.U_max, 100);
                linspace(obj.U_min, obj.U_max, 100)];

            obj.h = zeros(100,100);
            obj.pH = zeros(100,100);
            
            % Petla po siatce sterowań
            for i = 1:length(U)
                for j = 1:length(U)
                    u = [ones(1, 200)*U(1,i);
                         zeros(1, 200);
                         ones(1, 200)*U(2,j)];
                
                    [y, ~, ~] = obiekt.modifiedEuler(u, 200);
                    obj.h(i,j) =  y(1, end);
                    obj.pH(i,j) = y(2, end); 
                end
            end

            obj.Y_h = zeros(100, 100);
            obj.Y_pH = zeros(100, 100);
            
            y_h = zeros(1, 100);
            y_1 = zeros(1, 100);
            y_2 = zeros(1, 100);
            y_pH = zeros(1, 100);
            
            for i = 1:100
                for j = 1:100
                    u = [ones(1,100) * U(1,i);
                        ones(1,100) * U(2,j)];
                    for k = 2:length(u)
                        y_h(k) = - a_h.Q1*y_h(k-1) + b_h.Q1*u(1, k-1) + b_h.Q3*u(2, k-1);
            
                        if k >= 4
                            y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + b_pH.Q1*u(1,k-1);
                            y_2(k) = -a_pH.Q3 * y_2(k-1:-1:k-3)' + b_pH.Q3*u(2,k-1);
                            y_pH(k) = y_1(k) + y_2(k);
                        end
                    end
                    obj.Y_h(i,j) = y_h(end);
                    obj.Y_pH(i,j) = y_pH(end);
                end
            end
        end

        function linearFuzzy(obj)
            % -------------------- h --------------------% 
            Y_center = linspace(min(min(obj.Y_h)), max(max(obj.Y_h)), 4);
            obj.linear_fis.h = sugfis('Name', 'Linear_Wiener', 'Type', 'sugeno');
            obj.linear_fis.h = addInput(obj.linear_fis.h, [obj.Y_min obj.Y_max], 'Name', 'Y_linear');
            
            % Definiowanie funkcji przynależności (gaussmf)
            for i = 1:length(Y_center) 
                obj.linear_fis.h = addMF(obj.linear_fis.h, 'Y_linear', 'gaussmf', [12, Y_center(i)]);
            end
            
            % Definiowanie wyjścia i początkowych następników (a_i * y + b_i)
            obj.linear_fis.h = addOutput(obj.linear_fis.h, [min(min(obj.Y_h)) max(max(obj.Y_h))], 'Name', 'Y_fuzzy');
            
            % Początkowe współczynniki (a_i, b_i)
            a_param = [-0.0366 0.2409 0.5852 1.1168];
            b_param = [-15.5957 -4.4613	4.9938 7.2292];
            
            % Dodanie reguł TS w postaci liniowej
            for i = 1:length(Y_center)
                obj.linear_fis.h = addMF(obj.linear_fis.h, 'Y_fuzzy', 'linear', [a_param(i), b_param(i)]);
            end
            
            % Reguły Takagi-Sugeno: [inputMF, outputMF, weight]
            ruleList = [1 1 1 1;
                        2 2 1 1;
                        3 3 1 1;
                        4 4 1 1];
            
            % Dodanie reguł do systemu
            obj.linear_fis.h = addRule(obj.linear_fis.h, ruleList);

            % ------------------ pH ------------------ %
            % input_data = obj.Y_pH(:);
            % output_data = obj.pH(:);
            % 
            % opt = genfisOptions('SubtractiveClustering');
            % opt.ClusterInfluenceRange = 0.1;  % im mniejsze, tym więcej reguł
            % opt.SquashFactor = 1.25;  % tłumienie wpływu sąsiednich klastrów
            % opt.AcceptRatio = 0.6;
            % opt.RejectRatio = 0.4;
            % 
            % obj.linear_fis.pH = genfis(input_data, output_data, opt);

            X = obj.Y_pH(:);
            Y = obj.pH(:);
            % Generowanie systemu rozmytego
            fis = genfis1([X Y], 12, 'gaussmf', 'linear');
            % Trening ANFIS
            options = anfisOptions('InitialFIS', fis, 'EpochNumber', 200, ...
                'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            obj.linear_fis.pH = anfis([X Y], options);
        end

        function nonlinearFuzzy(obj)
            % ------------------ h ------------------ %
            obj.nonlinear_fis.h.Y_center = linspace(min(min(obj.Y_h)), max(max(obj.Y_h)), 3);
            obj.nonlinear_fis.h.sigma = 15;
            obj.nonlinear_fis.h.rules_number = 3;
            obj.nonlinear_fis.h.a_param = [	1.4191	9.4904	6.7729];
            obj.nonlinear_fis.h.b_param = [	-6.4250	-1.0296	14.0360];
            % output = output + degrees*(a_optimal(k)*sinh(Y_h(i,j)/15) + b_optimal(k));

            % ------------------ pH ------------------ %
            % obj.nonlinear_fis.pH.Y_center = [-19 -10 -4 0 4 10 19];
            % obj.nonlinear_fis.pH.sigma = 5;
            % obj.nonlinear_fis.pH.rules_number = 7;
            % obj.nonlinear_fis.pH.a_param = [33.9311	-8.9327	0.1175 18.3464 -45.5957	152.1874 -31.3801];
            % obj.nonlinear_fis.pH.b_param = [29.6727	-13.0869 1.8432	-15.3457 49.0125 -148.4482 35.5465];
            % output = output + degrees*(a_optimal(k)*tanh(Y_pH(i,j)) + b_optimal(k));

            X = tanh(obj.Y_pH(:)/30);
            Y = obj.pH(:);
            % Generowanie systemu rozmytego
            fis = genfis1([X Y], 4, 'gaussmf', 'linear');
            % Trening ANFIS
            options = anfisOptions('InitialFIS', fis, 'EpochNumber', 200, ...
                'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            obj.nonlinear_fis.pH = anfis([X Y], options);
        end

        function testLinearModel(obj, U, a_h, a_pH, b_h, b_pH, obiekt, type, index)
            [Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk); % Symulacja rzeczywistego układu
            t = 0:obiekt.Tp:(obiekt.kk-1)*obiekt.Tp; 
            Y_out = zeros(1, obiekt.kk);
            Y_fuzzy = zeros(1, obiekt.kk);

            % -------------------- LINEAR H -------------------- %
            if(strcmp(type, 'h'))
                for k = 2:obiekt.kk
                    Y_out(k) = - a_h.Q1*Y_out(k-1)' + b_h.Q1*U(1,k-1) + b_h.Q2 * U(2, k-1) + b_h.Q3 * U(3,k-1);
                    Y_fuzzy(k) = evalfis(obj.linear_fis.h, Y_out(k));
                end
                E_lin = sum((Y_real(1, :) - Y_lin(1, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(1, :) - Y_fuzzy).^2) / obiekt.kk;
                fprintf("\nWIENER LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(1, :), 'b', t, Y_lin(1, :), 'g', t, Y_fuzzy, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Wiener' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('h [cm]');
                xlabel('t [s]');
                grid on;

            % -------------------- LINEAR PH -------------------- %
            else
                y_1 = zeros(1,obiekt.kk);
                y_2 = zeros(1,obiekt.kk);
                y_3 = zeros(1,obiekt.kk);
                for k = 4:obiekt.kk
                    y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + b_pH.Q1*U(1,k-1);
                    y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + b_pH.Q2*U(2,k-1);
                    y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-3)' + b_pH.Q3*U(3,k-1);
                
                    Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                    Y_fuzzy(k) = evalfis(obj.linear_fis.pH, Y_out(k));
                end
                E_lin = sum((Y_real(2, :) - Y_lin(2, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(2, :) - Y_fuzzy).^2) / obiekt.kk;
                fprintf("\nWIENER LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(2, :), 'b', t, Y_lin(2, :), 'g', t, Y_fuzzy, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Wiener' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('pH');
                xlabel('t [s]');
                grid on;
            end

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/WienerLinearModel_%d.png', index));  % Zapisuje jako plik PNG
        end

        function testNonlinearModel(obj, U, a_h, a_pH, b_h, b_pH, obiekt, type, index)
            gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
            [Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk); % Symulacja rzeczywistego układu
            t = 0:obiekt.Tp:(obiekt.kk-1)*obiekt.Tp;

            Y_out = zeros(1,obiekt.kk);
            Y_fuzzy = zeros(1,obiekt.kk);

            % -------------------- NONLINEAR H -------------------- %
            if(strcmp(type, 'h'))
                for k = 2:obiekt.kk
                    Y_out(k) = - a_h.Q1*Y_out(k-1) + b_h.Q1*U(1,k-1) + b_h.Q2 * U(2, k-1) + b_h.Q3 * U(3,k-1);

                    output = 0;
                    w = 0;
                    for i = 1:obj.nonlinear_fis.h.rules_number
                        degrees = gaussmf_val(Y_out(k), obj.nonlinear_fis.h.sigma, obj.nonlinear_fis.h.Y_center(i));
                        output = output + degrees * (obj.nonlinear_fis.h.a_param(i)*sinh(Y_out(k)/15) + obj.nonlinear_fis.h.b_param(i));
                        w = w + degrees;
                    end
                    Y_fuzzy(k) = output / w;
                end
                E_lin = sum((Y_real(1, :) - Y_lin(1, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(1, :) - Y_fuzzy).^2) / obiekt.kk;
                fprintf("\nWIENER NONLINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(1, :), 'b', t, Y_lin(1, :), 'g', t, Y_fuzzy, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Wiener' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('h [cm]');
                xlabel('t [s]');
                grid on;

            % -------------------- NONLINEAR PH -------------------- %
            else
                % y_1 = zeros(1,obiekt.kk);
                % y_2 = zeros(1,obiekt.kk);
                % y_3 = zeros(1,obiekt.kk);
                % for k = 4:obiekt.kk
                %     y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + b_pH.Q1*U(1,k-1);
                %     y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + b_pH.Q2*U(2,k-1);
                %     y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-3)' + b_pH.Q3*U(3,k-1);
                % 
                %     Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                % 
                %     output = 0;
                %     w = 0;
                %     for i = 1:obj.nonlinear_fis.pH.rules_number
                %         degrees = gaussmf_val(Y_out(k), obj.nonlinear_fis.pH.sigma, obj.nonlinear_fis.pH.Y_center(i));
                %         output = output + degrees * (obj.nonlinear_fis.pH.a_param(i) * tanh(Y_out(k)) + obj.nonlinear_fis.pH.b_param(i));
                %         w = w + degrees;
                %     end
                %     Y_fuzzy(k) = output / w;
                % end

                y_1 = zeros(1,obiekt.kk);
                y_2 = zeros(1,obiekt.kk);
                y_3 = zeros(1,obiekt.kk);
                for k = 4:obiekt.kk
                    y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + b_pH.Q1*U(1,k-1);
                    y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + b_pH.Q2*U(2,k-1);
                    y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-3)' + b_pH.Q3*U(3,k-1);
                
                    Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                    Y_fuzzy(k) = evalfis(obj.nonlinear_fis.pH, tanh(Y_out(k)/30));
                end
                E_lin = sum((Y_real(2, :) - Y_lin(2, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(2, :) - Y_fuzzy).^2) / obiekt.kk;
                fprintf("\nWIENER NONLINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(2, :), 'b', t, Y_lin(2, :), 'g', t, Y_fuzzy, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Wiener' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Porównanie wyjścia obiektu testowego i jego modeli');
                ylabel('pH');
                xlabel('t [s]');
                grid on;
            end

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/WienerNonlinearModel_%d.png', index));  % Zapisuje jako plik PNG
        end

        function show_fuzzy(~, fis, s)
            figure;
            plotmf(fis, 'input', 1);
            title(sprintf('Funkcje przynależności dla Y - następniki %s', s));
            xlabel('y');
            ylabel('$\mu(y)$', 'Interpreter', 'latex');
            grid on;

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/WienerfuzzySets_%s.png', s));  % Zapisuje jako plik PNG
        end

    end
end
