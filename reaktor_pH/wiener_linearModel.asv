%% LINEAR WIENER MODEL
clear all;
obiekt = Obiekt();
[a_1, a_2, a_3, b_1, b_2, b_3, G_z] = obiekt.linearization(16.6, 0.55, 15.6);

% Zakres wyjścia liniowego bloku dynamicznego
Y_min = -30;
Y_max = 30;
Y_center = linspace(Y_min, Y_max, 5); % Środki zbiorów rozmytych

for i = 1:30
    if (i <= 15)
        U_tmp = [repelem([0, -7.5, -15, 7.5, 15], 420);
                 zeros(1, obiekt.kk);
                 repelem((rand(1, obiekt.kk/300) * 30 - 15), 300)];
    else
        U_tmp = [repelem((rand(1, obiekt.kk/300) * 30 - 15), 300);
                 zeros(1, obiekt.kk);
                 repelem([0, -7.5, -15, 7.5, 15], 420)];
    end
    [Y_tmp, ~] = obiekt.modifiedEuler(U_tmp, obiekt.kk);

    U_Q1(i, :) = U_tmp(1, :);
    U_Q3(i, :) = U_tmp(3, :);
    Y_train(i, :) = Y_tmp(1, :);
end
t = (0:length(U_Q1(1,:))-1) * obiekt.Tp;

%% Tworzenie systemu rozmytego TS dla Wienera
fis = sugfis('Name', 'Wiener', 'Type', 'sugeno');
fis = addInput(fis, [Y_min Y_max], 'Name', 'y');
rules_number = 5;
sigma = 8;

% Definiowanie funkcji przynależności (gaussmf)
for i = 1:length(Y_center) 
    fis = addMF(fis, 'y', 'gaussmf', [sigma, Y_center(i)]);
end

% Definiowanie wyjścia i początkowych następników (a_i * y + b_i)
fis = addOutput(fis, [Y_min Y_max], 'Name', 'y_fuzzy');

% Początkowe współczynniki (a_i, b_i)
a_param = ones(1,rules_number)*1;
b_param = ones(1,rules_number)*1;

% Dodanie reguł TS w postaci liniowej
for i = 1:length(Y_center)
    fis = addMF(fis, 'y_fuzzy', 'linear', [a_param(i), b_param(i)]);
end

% Reguły Takagi-Sugeno: [inputMF, outputMF, weight]
ruleList = [1 1 1 1;
            2 2 1 1;
            3 3 1 1;
            4 4 1 1;
            5 5 1 1];

% Dodanie reguł do systemu
fis = addRule(fis, ruleList);

% Optymalizacja przy pomocy fminsearch
initial_params = [a_param, b_param];  % Początkowe wartości a_param i b_param
options = optimset('Display', 'iter', 'MaxFunEvals', 1500, 'MaxIter', 1000); % Opcje optymalizacji
optimal_params = fminsearch(@(params) linearCoeff(params, fis, U_Q1, U_Q3, Y_train, Y_center, sigma, rules_number, a_1, b_1.Q_1, b_1.Q_3), initial_params, options);

% Po optymalizacji
a_optimal = optimal_params(1:rules_number);
b_optimal = optimal_params(rules_number+1:end);

% Wyświetlanie wyników optymalizacji
fprintf('Optymalne parametry a: \n');
disp(a_optimal);
fprintf('Optymalne parametry b: \n');
disp(b_optimal);

%% STOP
gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

for i = 1:rules_number
    fis.Outputs.MembershipFunctions(i).Parameters(1) = a_optimal(i);
    fis.Outputs.MembershipFunctions(i).Parameters(2) = b_optimal(i);
end

U = [repelem((rand(1, obiekt.kk/300) * 30 - 15), 300);
    zeros(1, obiekt.kk);
    repelem((rand(1, obiekt.kk/300) * 30 - 15), 300)];
[Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk); % Symulacja rzeczywistego układu

% Symulacja modelu Wienera
Y_out = zeros(1, obiekt.kk);
Y_fuzzy = zeros(1, obiekt.kk);
for k = obiekt.delay+3:obiekt.kk
    Y_out(k) = - a_1*[Y_out(k-1)]' + b_1.Q_1*U(1,k-1) + b_1.Q_3 * U(3,k-1);
    deg_y = [gaussmf_val(Y_out(k), sigma, Y_center(1)), gaussmf_val(Y_out(k), sigma, Y_center(2)), ...
                gaussmf_val(Y_out(k), sigma, Y_center(3)), gaussmf_val(Y_out(k), sigma, Y_center(4)), gaussmf_val(Y_out(k), sigma, Y_center(5))];
            
    w = 0;
    output = 0;
    for i = 1:length(fis.Rules)
        output = output +  deg_y(i)* (a_optimal(i)*y_out(k) + b_optimal(i));
        w = w + deg_y(i);
    end
    % y_fuzzy(k) = evalfis(fis, y_out(k));
    Y_fuzzy(k) = output / w;
end

% Wizualizacja wyników
figure;
plot(t, Y_real(1,:), 'b', t, Y_lin(1,:), 'g', t, Y_fuzzy, 'r');
% legend('RK4', 'RK4 liniowy', 'Wiener (optymalny TS)', 'Location', 'northwest');
title('Porównanie wyjścia układu rzeczywistego i modelu');

E_lin = sum((Y_real(1,:) - Y_lin).^2);
E_out = sum((Y_real(1,:) - Y_fuzzy).^2);
fprintf("\nE_lin = %.3f\n", E_lin);
fprintf("E_out = %.3f\n", E_out);

%% Losowość
for j = 1:5
    U = [repelem((rand(1, obiekt.kk/250) * 90 - 45), 250)];
    [Y_real, Y_lin] = obiekt.rk4([U; zeros(1, obiekt.kk)], obiekt.kk); % Symulacja rzeczywistego układu
    
    % Symulacja modelu Wienera
    y_out = zeros(1, obiekt.kk);
    Y_out = zeros(1, obiekt.kk);
    for k = obiekt.delay+3:obiekt.kk
        y_out(k) = - a*[y_out(k-1:-1:k-2)]' + b*[U(k-(obiekt.delay+1):-1:k-(obiekt.delay+2))]';
        Y_out(k) = evalfis(fis, y_out(k));
    end
    
    figure;
    plot(t, Y_real(1,:), 'b', t, Y_lin(1,:), 'g', t, Y_out, 'r');
    % legend('RK4', 'RK4 liniowy', 'Wiener (optymalny TS)', 'Location', 'northwest');
    title('Porównanie wyjścia układu rzeczywistego i modelu');
    
    E_lin = sum((Y_real(1,:) - Y_lin).^2);
    E_out = sum((Y_real(1,:) - Y_out).^2);
    fprintf("\n%d. E_lin = %.3f\n", j, E_lin);
    fprintf("%d. E_out = %.3f\n", j, E_out);
    grid on;
end

%% Funkcja do optymalizacji współczynników
function E_out = linearCoeff(params, fis, U_Q1, U_Q3, Y_real, Y_center, sigma, rules_number, a1, b1_q1, b1_q3)
    gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

    % Parametry do optymalizacji
    a_param = params(1:rules_number);
    b_param = params(rules_number+1:end);

    % Zaktualizuj model fuzzy z nowymi parametrami
    for i = 1:rules_number
        fis.Outputs.MembershipFunctions(i).Parameters(1) = a_param(i);
        fis.Outputs.MembershipFunctions(i).Parameters(2) = b_param(i);
    end

    % Inicjalizacja błędu
    [M, N] = size(U_Q1);  % M = liczba trajektorii
    E_out = 0;

    for traj = 1:M
        u_q1 = U_Q1(traj,:);
        u_q3 = U_Q3(traj,:);
        y_real_single = Y_real(traj, :);  % Odpowiadające wyjście

        y_out = zeros(1, N);
        y_fuzzy = zeros(1, N);

        for k = 2:N
            y_out(k) = -a1 * y_out(k-1) + b1_q1 * u_q1(k-1) + b1_q3 * u_q3(k-1);
            deg_y = [gaussmf_val(y_out(k), sigma, Y_center(1)), gaussmf_val(y_out(k), sigma, Y_center(2)), ...
                gaussmf_val(y_out(k), sigma, Y_center(3)), gaussmf_val(y_out(k), sigma, Y_center(4)), gaussmf_val(y_out(k), sigma, Y_center(5))];
            
            w = 0;
            output = 0;
            for i = 1:length(fis.Rules)
                output = output +  deg_y(i)* (a_param(i)*y_out(k) + b_param(i));
                w = w + deg_y(i);
            end
            % y_fuzzy(k) = evalfis(fis, y_out(k));
            y_fuzzy(k) = output / w;
        end

        % Sumuj błąd dla tej trajektorii
        E_out = E_out + sum((y_real_single - y_fuzzy).^2);
    end
end