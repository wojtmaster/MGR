classdef Hammerstein < handle

    properties
        U_min = -15;
        U_max = 15;
        Q1_grid
        Q3_grid
        h
        pH

        linear_fis
        nonlinear_fis
    end

    methods
        function obj = Hammerstein(obiekt)
            U = [linspace(1.6, 31.6, 100)
                linspace(0.6, 30.6, 100)];
            [obj.Q1_grid, obj.Q3_grid] = meshgrid(U(1,:), U(2,:));
            obj.h = ((obj.Q1_grid + obiekt.Q_20 + obj.Q3_grid) / obiekt.C_V).^2 - obiekt.h_0;
            Wa4 = (obiekt.W_a1*obj.Q1_grid + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*obj.Q3_grid)./(obj.Q1_grid+obiekt.Q_20+obj.Q3_grid);
            Wb4 = (obiekt.W_b1*obj.Q1_grid + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*obj.Q3_grid)./(obj.Q1_grid+obiekt.Q_20+obj.Q3_grid);
            
            for i = 1:100
                for j = 1:100
                    obj.pH(i,j) = obiekt.pH_calc(Wa4(i,j), Wb4(i,j)) - obiekt.pH_0;
                end
            end

            U = [linspace(obj.U_min, obj.U_max, 100);
                linspace(obj.U_min, obj.U_max, 100)];
            [obj.Q1_grid, obj.Q3_grid] = meshgrid(U(1,:), U(2,:));  % kombinacje
        end

        function linearFuzzy(obj)
            % --------------- LINEAR H --------------- %
            X1 = obj.Q1_grid';  X2 = obj.Q3_grid';
            X = [X1(:) X2(:)];
            
            Y = obj.h';
            Y = Y(:);

            % Generowanie systemu rozmytego
            fis = genfis1([X Y], 5, 'gaussmf', 'linear');
            % Trening ANFIS
            options = anfisOptions('InitialFIS', fis, 'EpochNumber', 100, ...
                'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            obj.linear_fis.h = anfis([X Y], options);

            % --------------- LINEAR PH --------------- %
            X = (X1(:)-X2(:))/2;
            
            Y = obj.pH';
            Y = Y(:);

            % Generowanie systemu rozmytego
            fis = genfis1([X Y], 12, 'gaussmf', 'linear');
            % Trening ANFIS
            options = anfisOptions('InitialFIS', fis, 'EpochNumber', 100, ...
                'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            obj.linear_fis.pH = anfis([X Y], options);
        end

        function nonlinearFuzzy(obj)
            % --------------- NONLINEAR H --------------- %
            X1 = obj.Q1_grid';  X2 = obj.Q3_grid';
            X = [sinh(X1(:)/15) sinh(X2(:)/15)];

            Y = obj.h';
            Y = Y(:);
            
            % Generowanie systemu rozmytego
            fis = genfis1([X Y], 3, 'gaussmf', 'linear');
            % Trening ANFIS
            options = anfisOptions('InitialFIS', fis, 'EpochNumber', 100, ...
                'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            obj.nonlinear_fis.h = anfis([X Y], options);
        
            % % --------------- NONLINEAR PH --------------- %
            X = tanh((X1(:)-X2(:))/15);
            
            Y = obj.pH';
            Y = Y(:);

            % Generowanie systemu rozmytego
            fis = genfis1([X Y], 6, 'gaussmf', 'linear');
            % Trening ANFIS
            options = anfisOptions('InitialFIS', fis, 'EpochNumber', 100, ...
                'DisplayANFISInformation', 0, 'DisplayErrorValues', 0);
            obj.nonlinear_fis.pH = anfis([X Y], options);
        end

        function testLinearModel(obj, U, a_h, a_pH, b_h, b_pH, obiekt, type, index)
            [Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk);
            t = 0:obiekt.Tp:(obiekt.kk-1)*obiekt.Tp; 
            v = zeros(1, obiekt.kk);
            Y_out = zeros(1, obiekt.kk);
            
            % --------------- LINEAR H --------------- %
            if(strcmp(type, 'h'))
                Y_fuzzy = evalfis(obj.linear_fis.h, [U(1,:)', U(3,:)']);
                for k = 3:obiekt.kk
                    if(U(1,k-1) + U(3, k-1) ~= 0)
                        K = Y_fuzzy(k-1) / (U(1, k-1) + U(3, k-1));
                    else
                        K = 1;
                    end

                    Y_out(k) = - a_h*Y_out(k-1) + K*b_h*U(1, k-1) + b_h*U(2, k-1) + K*b_h*U(3, k-1);
                end

                E_lin = sum((Y_real(1, :) - Y_lin(1, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(1, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(1, :), 'b', t, Y_lin(1, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Por�wnanie wyj�cia obiektu testowego i jego modeli');
                ylabel('h [cm]');
                xlabel('t [s]');
                grid on;

            % --------------- LINEAR PH --------------- %
            else
                du = 0.001;
                Y_fuzzy = evalfis(obj.linear_fis.pH, (U(1,:)'- U(3,:)')/2);
                Y_fuzzy_Q1 = evalfis(obj.linear_fis.pH, (U(1,:)' + du - U(3,:)')/2);
                Y_fuzzy_Q3 = evalfis(obj.linear_fis.pH, (U(1,:)'- (U(3,:)' + du))/2);

                y_1 = zeros(1,obiekt.kk);
                y_2 = zeros(1,obiekt.kk);
                y_3 = zeros(1,obiekt.kk);


                a_Hamm=a_pH.Q1;
                b_Hamm=-b_pH.Q1;
                Y_stat(1:3)=Y_out(1);

                for k = 4:obiekt.kk

                    if(abs(U(1,k-1) + U(3, k-1)) ~= 0 )
                        dydQ = Y_fuzzy(k-1) / (U(1,k-1) + U(3,k-1));
                    else
                        dydQ = 1;
                    end

                    dydQ1 = (Y_fuzzy(k-1) - Y_fuzzy_Q1(k-1)) / du;
                    dydQ3 = abs((Y_fuzzy_Q3(k-1) - Y_fuzzy(k-1)) / du);
                    % y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + dydQ1*b_pH.Q1 * U(1, k-1:-1:k-2)';
                    % y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + b_pH.Q2*U(2,k-1:-1:k-2)';
                    % y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-2)' + dydQ3*b_pH.Q3 * U(3, k-1:-1:k-2)';
                    % Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                    % -a_pH.Q1 * Y_out(k-1:-1:k-2)' + dydQ1*b_pH.Q1 * U(1, k-1:-1:k-2)';

                    Wa4 = (obiekt.W_a1*(obiekt.Q_10+U(1,k-1)) + obiekt.W_a2*obiekt.Q_20 + obiekt.W_a3*(obiekt.Q_30+U(3,k-1)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+U(1,k-1)+U(3,k-1));
                    Wb4 = (obiekt.W_b1*(obiekt.Q_10+U(1,k-1)) + obiekt.W_b2*obiekt.Q_20 + obiekt.W_b3*(obiekt.Q_30+U(3,k-1)))./(obiekt.Q_10+obiekt.Q_20+obiekt.Q_30+U(1,k-1)+U(3,k-1));
                    Y_stat(k) = obiekt.pH_calc(Wa4, Wb4) - obiekt.pH_0;
                    % Y_out(k) = Y_stat(k);
                    Y_out(k) = -a_Hamm * Y_out(k-1:-1:k-2)' + b_Hamm * Y_stat(k:-1:k-1)';
                end

                E_lin = sum((Y_real(2, :) - Y_lin(2, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(2, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(2, :), 'b', t, Y_lin(2, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);

                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');

                title('Por�wnanie wyj�cia obiektu testowego i jego modeli');
                ylabel('pH');
                xlabel('t [s]');
                grid on;
            end

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/HammersteinLinearModel_%d.png', index));  % Zapisuje jako plik PNG
        end

        function testNonlinearModel(obj, U, a_h, a_pH, b_h, b_pH, obiekt, type, index)
            
            [Y_real, Y_lin] = obiekt.modifiedEuler(U, obiekt.kk);
            t = 0:obiekt.Tp:(obiekt.kk-1)*obiekt.Tp; 
            Y_out = zeros(1, obiekt.kk);

            % --------------- NONLINEAR H --------------- %
            if(strcmp(type, 'h'))
                Y_fuzzy = evalfis(obj.nonlinear_fis.h, [sinh(U(1,:)'/15), sinh(U(3,:)'/15)]);
                for k = 2:obiekt.kk
                    if(U(1,k-1) + U(3, k-1) ~= 0)
                        K = Y_fuzzy(k-1) / (U(1, k-1) + U(3, k-1));
                    else
                        K = 1;
                    end
                    Y_out(k) = - a_h*Y_out(k-1) + K*b_h*U(1, k-1) + b_h*U(2, k-1) + K*b_h*U(3, k-1);
                end

                E_lin = sum((Y_real(1, :) - Y_lin(1, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(1, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(1, :), 'b', t, Y_lin(1, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);
                
                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');
    
                title('Por�wnanie wyj�cia obiektu testowego i jego modeli');
                ylabel('h [cm]');
                xlabel('t [s]');
                grid on;

            % --------------- NONLINEAR PH --------------- %
            else
                du = 0.001;
                % Y_fuzzy = evalfis(obj.nonlinear_fis.pH, tanh((U(1,:)'- U(3,:)')/15));
                % Y_fuzzy_Q1 = evalfis(obj.nonlinear_fis.pH, tanh((U(1,:)' + du - U(3,:)')/15));
                Y_fuzzy_Q3 = evalfis(obj.nonlinear_fis.pH, tanh((U(1,:)'- (U(3,:)' + du))/15));

                y_1 = zeros(1,obiekt.kk);
                y_2 = zeros(1,obiekt.kk);
                y_3 = zeros(1,obiekt.kk);

                for k = 4:obiekt.kk
                    Y_fuzzy = evalfis(obj.nonlinear_fis.pH, tanh((U(1,k))/15));
                    Y_fuzzy_Q1 = evalfis(obj.nonlinear_fis.pH, tanh((U(1,k) + du)/15));
                    dydQ1 = (Y_fuzzy - Y_fuzzy_Q1) / du ;
                    % disp(dydQ1);
                    % dydQ3 = abs((Y_fuzzy_Q3(k-1) - Y_fuzzy(k-1)) / du);
                    % y_1(k) = -a_pH.Q1 * y_1(k-1:-1:k-2)' + dydQ1*b_pH.Q1 * U(1, k-1:-1:k-2)';
                    % y_2(k) = -a_pH.Q2 * y_2(k-1:-1:k-2)' + b_pH.Q2*U(2,k-1:-1:k-2)';
                    % y_3(k) = -a_pH.Q3 * y_3(k-1:-1:k-2)' + dydQ3*b_pH.Q3 * U(3, k-1:-1:k-2)';
                    % Y_out(k) = y_1(k) + y_2(k) + y_3(k);
                    Y_out(k) = -a_pH.Q1 * Y_out(k-1:-1:k-2)' + b_pH.Q1 * U(1, k-1:-1:k-2)';
                end

                E_lin = sum((Y_real(2, :) - Y_lin(2, :)).^2) / obiekt.kk;
                E_out = sum((Y_real(2, :) - Y_out).^2) / obiekt.kk;
                fprintf("\nHAMMERSTEIN LINEAR MODEL\n");
                fprintf("E_lin = %.3f\n", E_lin);
                fprintf("E_out = %.3f\n", E_out);
    
                figure;
                plot(t, Y_real(2, :), 'b', t, Y_lin(2, :), 'g', t, Y_out, 'r', 'LineWidth', 1.5);

                legend({'model nieliniowy', ...
                        ['model liniowy' blanks(17) sprintf('E = %.3f', E_lin)], ...
                        ['model Hammersteina' blanks(5) sprintf('E = %.3f', E_out)]}, ...
                        'Location', 'best');

                title('Por�wnanie wyj�cia obiektu testowego i jego modeli');
                ylabel('pH');
                xlabel('t [s]');
                grid on;
                % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/HammersteinNonlinearModel_%d.png', index));  % Zapisuje jako plik PNG
            end
        end

        function show_fuzzy(~, fis, s)
            figure;
            plotmf(fis, 'input', 1);
            title(sprintf('Funkcje przynale�no�ci dla u(k) - nast�pniki %s', s));
            xlabel('u');
            ylabel('$\mu(u)$', 'Interpreter', 'latex');
            grid on;

            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/HammersteinfuzzySets_%s.png', s));  % Zapisuje jako plik PNG
        end
    end
end