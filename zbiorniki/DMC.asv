classdef DMC < handle
    properties
        N
        Nu
        D
        D_disturbance
        M
        M_p
        M_zP
        K
        ke
        ku
        kz
        lambda

        u_max = 45;
        delta_uk_max = 2.5;
        y_max = 25;
    end

    methods
        function obj = DMC(N, Nu, D, D_disturbance, lambda)
            obj.N = N;
            obj.Nu = Nu;
            obj.D = D;
            obj.D_disturbance = D_disturbance;
            obj.lambda = lambda;
        end

        function dynamic_matrix(obj, s)
            obj.M = zeros(obj.N, obj.Nu);
            
            % Implementacja macierzy M
            for i = 1:obj.N
                for j = 1:obj.Nu
                    if(i >= j)
                        obj.M(i,j) = s(i-j+1);
                    end
                end
            end

            % Macierz K
            obj.K = ((obj.M' * obj.M + obj.lambda * eye(obj.Nu))^(-1)) * obj.M';
            obj.ke = sum(obj.K(1, :));          
        end

        function past_matrix(obj, s)
            obj.M_p = zeros(obj.N, obj.D-1);
        
            % Implementacja macierzy M_p
            for i = 1:obj.N
                for j = 1:obj.D-1
                    if(i+j <= obj.D)
                        obj.M_p(i,j) = s(i+j) - s(j);
                    else 
                        obj.M_p(i,j) = s(obj.D) - s(j);
                    end
                end
            end
            obj.ku = obj.K(1, :) * obj.M_p;
        end

        function matrix_disturbance(obj, s)
            obj.M_zP = zeros(obj.N, obj.D_disturbance-1);

            % Implementacja macierzy M_zP
            for i = 1:obj.N
                for j = 1:obj.D_disturbance-1
                    if(i+j <= obj.D_disturbance)
                        obj.M_zP(i,j) = s(i+j) - s(j);
                    else 
                        obj.M_zP(i,j) = s(obj.D_disturbance) - s(j);
                    end
                end
            end

            obj.M_zP = [s(1:obj.N), obj.M_zP];
            obj.kz = obj.K(1, :) * obj.M_zP;
        end
   
        function [y, u, E, E_u, E_y] = dmc_analitic(obj, y_zad, u_D, a, b, delay, kk)
            %% Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;
        
            delta_up = zeros(1, obj.D-1);
            delta_uz = zeros(1, obj.D_disturbance);
            delta_uk = 0;
            delta_u = zeros(1, kk);
            
            %% Sterowanie DMC
            v = zeros(size(y_zad));
            y = zeros(size(y_zad));
            v(1:delay+2) = y_zad(1:delay+2);
            y(1:delay+2) = y_zad(1:delay+2);
            for k = delay+3:kk
                v(k) = - a*v(k-1:-1:k-2)' + b*u(1, k-(delay+1):-1:k-(delay+2))' + b*u(2, k-1:-1:k-2)';
                y(k) = ((120+v(k))/20)^2 - 36;
        
                % Ograniczenia wartości sygnału wyjściowego, tj. wysokości h_2
                y(k) = min(y(k), obj.y_max);
                y(k) = max(y(k), -obj.y_max);
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk, delta_up(1:end-1)];
                delta_uz = [u(2, k) - u(2, k-1), delta_uz(1:end-1)];
        
                % Obliczenie uchybu    
                e = y_zad(k) - y(k);
            
                % Obliczenie przyrostu sterowania dla chwili (i+1) w chwili i-tej
                delta_uk = obj.ke * e - obj.ku * delta_up' - obj.kz * delta_uz';
                
                % Ograniczenie wartości przyrostu sterowania
                delta_uk = min(delta_uk, obj.delta_uk_max);
                delta_uk = max(delta_uk, -obj.delta_uk_max);
                delta_u(k) = delta_uk;
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk;
                
                % Ograniczenie sterowania
                u(1, k) = min(u(1, k), obj.u_max);
                u(1, k) = max(u(1, k), -obj.u_max);
            end
            E_u = obj.lambda .* sum(delta_u.^2)/kk;
            E_y = sum((y_zad - y).^2)/kk;
            E =  E_u + E_y;
        end

        function [y, u, E, E_u, E_y] = dmc_numeric(obj, y_zad, u_D, a, b, delay, kk)
            % Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;
            
            delta_up = zeros(obj.D-1,1);
            delta_uk = zeros(obj.Nu,1);
            delta_uz = zeros(obj.D_disturbance, 1);
            delta_u = zeros(1, kk);
        
            Y_max = ones(obj.N,1)*obj.y_max;
            Y_min = ones(obj.N,1)*(-obj.y_max);
            
            U_max = ones(obj.Nu,1)*obj.u_max;
            U_min = ones(obj.Nu,1)*(-obj.u_max);
            delta_U_max = ones(obj.Nu,1)*obj.delta_uk_max;
            delta_U_min = ones(obj.Nu,1)*(-obj.delta_uk_max);
            
            J = tril(ones(obj.Nu));
            A = [-J; J; -obj.M; obj.M];
            H = 2*(obj.M'*obj.M + obj.lambda*eye(obj.Nu));
            
            v = zeros(size(y_zad));
            y = zeros(size(y_zad));
            v(1:delay+2) = y_zad(1:delay+2);
            y(1:delay+2) = y_zad(1:delay+2);
            for k = delay+3:kk
                v(k) = - a*v(k-1:-1:k-2)' + b*u(1, k-(delay+1):-1:k-(delay+2))' + b*u(2, k-1:-1:k-2)';
                y(k) = ((120+v(k))/20)^2 - 36;
        
                % Ograniczenia wartości sygnału wyjściowego, tj. wysokości h_2
                y(k) = min(y(k), obj.y_max);
                y(k) = max(y(k), -obj.y_max);
                   
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk(1); delta_up(1:end-1)];
                delta_uz = [u(2, k) - u(2, k-1); delta_uz(1:end-1)];
            
                U_k_1 = ones(obj.Nu,1)*u(1,k-1);
                Y = ones(obj.N,1)*y(k);
                Y_0 = Y + obj.M_p*delta_up + obj.M_zP*delta_uz;
                Y_zad = ones(obj.N,1)*y_zad(k);
                B = [-U_min + U_k_1;
                     U_max - U_k_1;
                    -Y_min + Y_0;
                     Y_max - Y_0];
                f = -2*obj.M'*(Y_zad - Y_0);
                
                % Obliczenie przyrostu sterowania dla chwili (i+1) w chwili i-tej
                options = optimoptions('quadprog', 'Display', 'off');
                delta_uk = quadprog(H,f,A,B,[],[],delta_U_min,delta_U_max,[],options);
                delta_u(k) = delta_uk(1);
                
                % Obliczenie sterowania
                u(1,k) = u(1,k-1) + delta_uk(1);
            end
            E_u = obj.lambda .* sum(delta_u.^2)/kk;
            E_y = sum((y_zad - y).^2)/kk;
            E =  E_u + E_y;
        end

        function [y, u, E, E_u, E_y] = dmc_fuzzy(obj, y_zad, u_D, a, b, delay, kk, obiekt)
            gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
        
            %% Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;
        
            delta_up = zeros(1, obj.D-1);
            delta_uz = zeros(1, obj.D_disturbance);
            delta_uk = 0;
            delta_u = zeros(1, kk);
        
            F_10 = obiekt.F_10;
            F_D0 = obiekt.F_D0;
            h_20 = obiekt.h_20;
        
            F_1 = [-30 -10 0 10 30];
            F_D = [-10 -5 0 5 10];
            sigma = 12;
            rules_number = length(F_1);
            Y = zeros(1, rules_number);
            KE = zeros(1, rules_number);
            KU = cell(1, rules_number);
            KZ = cell(1, rules_number);
            L = ones(1,rules_number)*2.5;
        
            for i = 1:rules_number
                obiekt.linearization(F_10+F_1(i), F_D0+F_D(i));
                [~, ~, s, s_D] = obiekt.sopdt();
                obj.lambda = L(i);
                obj.dynamic_matrix(s);
                obj.past_matrix(s);
                obj.matrix_disturbance(s_D);
        
                Y(i) = obiekt.h_20 - h_20;
                KE(i) = obj.ke;
                KU{i} = obj.ku;
                KZ{i} = obj.kz;
            end
            disp(Y);
        
            %% Sterowanie DMC
            v = zeros(size(y_zad));
            y = zeros(size(y_zad));
            v(1:delay+2) = y_zad(1:delay+2);
            y(1:delay+2) = y_zad(1:delay+2);
            for k = delay+3:kk
                v(k) = - a*v(k-1:-1:k-2)' + b*u(1, k-(delay+1):-1:k-(delay+2))' + b*u(2, k-1:-1:k-2)';
                y(k) = ((120+v(k))/20)^2 - 36;
        
                % Ograniczenia wartości sygnału wyjściowego, tj. wysokości h_2
                y(k) = min(y(k), obj.y_max);
                y(k) = max(y(k), -obj.y_max);
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk, delta_up(1:end-1)];
                delta_uz = [u(2, k) - u(2, k-1) , delta_uz(1:end-1)];
        
                % Oblicznie uchybu    
                e = y_zad(k) - y(k);
        
                output = 0;
                w = 0;
                for i = 1:rules_number
                    degree = gaussmf_val(v(k), sigma, Y(i));
                    output = output + degree * (KE(i) * e - KU{i} * delta_up' - KZ{i} * delta_uz');
                    w = w + degree;
                end
                delta_uk = output / w;
        
                % Ograniczenie wartości przyrostu sterowania
                delta_uk = min(delta_uk, obj.delta_uk_max);
                delta_uk = max(delta_uk, -obj.delta_uk_max);
                delta_u(k) = delta_uk;
        
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk;
        
                % Ograniczenie sterowania
                u(1, k) = min(u(1, k), obj.u_max);
                u(1, k) = max(u(1, k), -obj.u_max);
            end
            E_u = obj.lambda .* sum(delta_u.^2)/kk;
            E_y = sum((y_zad - y).^2)/kk;
            E =  E_u + E_y;
        end

        function [y, u, E, E_u, E_y] = dmc_no(obj, y_zad, u_D, a, b, delay, kk)
            %% Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;

            delta_u_hist = zeros(1, kk);
            
            %% Sterowanie DMC
            v = zeros(size(y_zad));
            y = zeros(size(y_zad));
            v(1:delay+2) = y_zad(1:delay+2);
            y(1:delay+2) = y_zad(1:delay+2);
        
            for k = delay+3:kk
                v(k) = - a*v(k-1:-1:k-2)' + b*u(1, k-(delay+1):-1:k-(delay+2))' + b*u(2, k-1:-1:k-2)';
                y(k) = ((120 + v(k))/20)^2 - 36;
                
                cost_func = @(du) (sum((y_zad(k)*ones(obj.N,1) - nonlinear_func(v, u, du, k, a, b, obj.N)).^2) + obj.lambda * sum(du.^2));
  
                % Ograniczenia na przyrosty sterowania
                lb = -obj.delta_uk_max * ones(obj.Nu, 1);
                ub = obj.delta_uk_max * ones(obj.Nu, 1);
                
                % Optymalizacja
                options = optimoptions('fmincon', 'Display', 'none', ...
                    'Algorithm', 'sqp', 'OptimalityTolerance', 1e-6, 'StepTolerance', 1e-6);
                delta_u = fmincon(cost_func, zeros(obj.Nu, 1), [], [], [], [], lb, ub, [], options);
                delta_uk = delta_u(1);
        
                % Aktualizacja sterowania
                u(1, k) = u(1, k-1) + delta_uk;
                delta_u_hist(k) = delta_uk;
            end
        
            E_u = obj.lambda .* sum(delta_u_hist.^2) / kk;
            E_y = sum((y_zad - y).^2) / kk;
            E = E_u + E_y;
        
            function y_pred = nonlinear_func(v, u, du, k, a, b, N)
                y_pred = zeros(N,1);
                v_pred = zeros(N,1);
                u_pred = zeros(N,1);
            
                v_prev1 = v(k);
                v_prev2 = v(k-1);
            
                for i = 1:N
                    % wyliczenie przyrostu sterowania
                    if i <= length(du)
                        du_i = du(i);
                    else
                        du_i = du(end);
                    end
            
                    % predykcja u1
                    if i == 1
                        u_pred(i) = u(1, k-1) + du_i;
                    else
                        u_pred(i) = u_pred(i-1) + du_i;
                    end
            
                    % u1 z opóźnieniem: różne źródło w zależności od i
                    if i < 6
                        u1_delayed_1 = u(1, k - 6 + i);       % znane
                        u1_delayed_2 = u(1, k - 7 + i);
                    elseif (i == 6)
                        u1_delayed_1 = u_pred(i - 5);         % przewidywane
                        u1_delayed_2 = u(1, k - 7 + i);
                    else
                        u1_delayed_1 = u_pred(i - 5);         % przewidywane
                        u1_delayed_2 = u_pred(i - 6);
                    end
            
                    % u2 zakładamy stałe
                    u2_delayed_1 = u(2, k - 1);
                    u2_delayed_2 = u(2, k - 2);
            
                    % predykcja stanu
                    v_pred(i) = -a * [v_prev1; v_prev2] ...
                              + b * [u1_delayed_1; u1_delayed_2] ...
                              + b * [u2_delayed_1; u2_delayed_2];
            
                    y_pred(i) = ((120 + v_pred(i)) / 20)^2 - 36;
            
                    % aktualizacja stanu
                    v_prev2 = v_prev1;
                    v_prev1 = v_pred(i);
                end
            end
        end

        function [y, u, E, E_u, E_y] = dmc_slHammerstein(obj, y_zad, u_D, a, b, fis, delay, kk, type)
            %% Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;

            delta_up = zeros(1, obj.D-1);
            delta_uz = zeros(1, obj.D_disturbance);
            delta_uk = 0;
            delta_u = zeros(1, kk);

            du = 0.001;
            
            %% Sterowanie DMC
            y = zeros(size(y_zad));
            y(1:delay+2) = y_zad(1:delay+2);
            v = zeros(size(y_zad));
            for k = delay+3:kk

                if (strcmp(type, 'linear'))
                    dydu = (evalfis(fis, [u(1,k-(delay+1)), u(2,k-1)]) - evalfis(fis, [u(1,k-(delay+1))-du, u(2,k-1)]))/du;
                else
                    gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

                    w = 0;
                    output = 0;
                    for i = 1:3
                        for j = 1:2
                            idx = (i - 1) * 2 + j;

                            deg_u1 = gaussmf_val(u(1,k-(delay+1)), fis.sigma_F1, fis.F1_center(i));
                            deg_u2 = gaussmf_val(u(2,k-1), fis.sigma_FD, fis.FD_center(j));
                    
                            degrees = deg_u1 * deg_u2;
    
                            output = output + degrees*(fis.a_param(idx)*sinh(u(1,k-(delay+1))/22.5) + fis.b_param(idx)*sinh(u(2,k-1)/7.5) + fis.c_param(idx));
                            w = w + degrees;
                        end
                    end
                    v_k = output / w;

                    w = 0;
                    output = 0;
                    for i = 1:3
                        for j = 1:2
                            idx = (i - 1) * 2 + j;

                            deg_u1 = gaussmf_val(u(1,k-(delay+1))-du, fis.sigma_F1, fis.F1_center(i));
                            deg_u2 = gaussmf_val(u(2,k-1), fis.sigma_FD, fis.FD_center(j));
                    
                            degrees = deg_u1 * deg_u2;
    
                            output = output + degrees*(fis.a_param(idx)*sinh((u(1,k-(delay+1))-du)/22.5) + fis.b_param(idx)*sinh(u(2,k-1)/7.5) + fis.c_param(idx));
                            w = w + degrees;
                        end
                    end
                    v_k_1 = output / w;

                    dydu = (v_k - v_k_1) / du;
                end
                
                v(k) = ((90+u(1,k-(delay+1)) + 30 + u(2, k-1)) /20)^2 - 36;
                y(k) = - a*y(k-1:-1:k-2)' + b*v(k-1:-1:k-2)';

                % Ograniczenia wartości sygnału wyjściowego, tj. wysokości h_2
                y(k) = min(y(k), obj.y_max);
                y(k) = max(y(k), -obj.y_max);

                M_new = dydu * obj.M;
                K_new = ((M_new' * M_new + obj.lambda * eye(obj.Nu))^(-1)) * M_new';
                ke_new = sum(K_new(1, :));
        
                Mp_new = dydu * obj.M_p;
                ku_new = K_new(1,:) * Mp_new;
        
                MzP_new = dydu * obj.M_zP;
                kz_new = K_new(1,:) * MzP_new;

                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk, delta_up(1:end-1)];
                delta_uz = [u(2, k) - u(2, k-1) , delta_uz(1:end-1)];

                % Oblicznie uchybu    
                e = y_zad(k) - y(k);
            
                % Obliczenie przyrostu sterowania dla chwili (i+1) w chwili i-tej
                delta_uk = ke_new * e - ku_new * delta_up' - kz_new * delta_uz';
                
                % Ograniczenie wartości przyrostu sterowania
                delta_uk = min(delta_uk, obj.delta_uk_max);
                delta_uk = max(delta_uk, -obj.delta_uk_max);
                delta_u(k) = delta_uk;
                
                % Obliczenie sterowania dla chwili (i+1) w chwili i-tej
                u(1, k) = u(1, k-1) + delta_uk; 
                
                % Ograniczenie sterowania
                u(1, k) = min(u(1, k), obj.u_max);
                u(1, k) = max(u(1, k), -obj.u_max);
            end
            E_u = obj.lambda .* sum(delta_u.^2)/kk;
            E_y = sum((y_zad - y).^2)/kk;
            E =  E_u + E_y;
        end

        function [y, u, E, E_u, E_y] = dmc_nplHammerstein(obj, y_zad, u_D, a, b, fis, delay, kk, type)
            % Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;

            delta_u = zeros(1, kk);

            du = 0.001;
            
            % Sterowanie DMC
            y = zeros(size(y_zad));
            y(1:delay+2) = y_zad(1:delay+2);
            v = zeros(size(y_zad));
            % Główna pętla sterowania
            for k = delay+3:kk
                
                % Obliczenie wzmocnienia z modelu Hammersteina
                if (strcmp(type, 'linear'))
                    dydu = (evalfis(fis, [u(1,k-(delay+1)), u(2,k-1)]) - evalfis(fis, [u(1,k-(delay+1))-du, u(2,k-1)]))/du;
                else
                    gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

                    w = 0;
                    output = 0;
                    for i = 1:3
                        for j = 1:2
                            idx = (i - 1) * 2 + j;

                            deg_u1 = gaussmf_val(u(1,k-(delay+1)), fis.sigma_F1, fis.F1_center(i));
                            deg_u2 = gaussmf_val(u(2,k-1), fis.sigma_FD, fis.FD_center(j));
                    
                            degrees = deg_u1 * deg_u2;
    
                            output = output + degrees*(fis.a_param(idx)*sinh(u(1,k-(delay+1))/22.5) + fis.b_param(idx)*sinh(u(2,k-1)/7.5) + fis.c_param(idx));
                            w = w + degrees;
                        end
                    end
                    v_k = output / w;

                    w = 0;
                    output = 0;
                    for i = 1:3
                        for j = 1:2
                            idx = (i - 1) * 2 + j;

                            deg_u1 = gaussmf_val(u(1,k-(delay+1))-du, fis.sigma_F1, fis.F1_center(i));
                            deg_u2 = gaussmf_val(u(2,k-1), fis.sigma_FD, fis.FD_center(j));
                    
                            degrees = deg_u1 * deg_u2;
    
                            output = output + degrees*(fis.a_param(idx)*sinh((u(1,k-(delay+1))-du)/22.5) + fis.b_param(idx)*sinh(u(2,k-1)/7.5) + fis.c_param(idx));
                            w = w + degrees;
                        end
                    end
                    v_k_1 = output / w;

                    dydu = (v_k - v_k_1) / du;
                end
                
                v(k) = ((90+u(1,k-(delay+1)) + 30 + u(2, k-1)) / 20)^2 - 36;
                V = evalfis(fis, [u(1,k-(delay+1)), u(2,k-1)]);
                
                y(k) = - a*y(k-1:-1:k-2)' + b*v(k-1:-1:k-2)';
                
                M_new = dydu * obj.M;
                K_new = ((M_new' * M_new + obj.lambda * eye(obj.Nu))^(-1)) * M_new';
        
                Y_0 = fuzzy_free_response(u, v, y, k, a, b, obj.N, fis, type);
                Y_zad = y_zad(k) * ones(obj.N, 1);
                delta_uk = K_new(1,:) * (Y_zad - Y_0);
        
                % Ograniczenia przyrostu
                delta_uk = min(max(delta_uk, -obj.delta_uk_max), obj.delta_uk_max);
        
                % Aktualizacja sterowania
                u(1, k) = u(1, k-1) + delta_uk;
        
                % Ograniczenia sterowania
                u(1, k) = min(max(u(1, k), -obj.u_max), obj.u_max);
        
                delta_u(k) = delta_uk;
            end

            E_u = obj.lambda .* sum(delta_u.^2)/kk;
            E_y = sum((y_zad - y).^2)/kk;
            E =  E_u + E_y;

            function y_0 = fuzzy_free_response(u, v, y, k, a, b, N, fis, type)
                y_0 = zeros(N, 1);
                v_0 =  v(1, k);
                u_10 = u(1, k-6);
                u_20 = u(2, k-1);
        
                if (strcmp(type, 'linear'))
                    v_hat = evalfis(fis, [u(1, k-(delay+1)) u(2, k-1)]);
                else
                    output = 0;
                    w = 0;
                    for m = 1:3
                        for n = 1:2
                            idx = (m - 1) * 2 + n;

                            deg_u1 = gaussmf_val(u(1,k-(delay+1)), fis.sigma_F1, fis.F1_center(m));
                            deg_u2 = gaussmf_val(u(2,k-1), fis.sigma_FD, fis.FD_center(n));
                    
                            degrees = deg_u1 * deg_u2;
    
                            output = output + degrees*(fis.a_param(idx)*sinh(u(1,k-(delay+1))/22.5) + fis.b_param(idx)*sinh(u(2,k-1)/7.5) + fis.c_param(idx));
                            w = w + degrees;
                        end
                    end
                    v_hat = output / w;
                end
                
                if ((u(1, k-(delay+1)) - u(2, k-1)) > 1e-3) 
                    dvdu = v_hat / (u(1, k-(delay+1)) - u(2, k-1));
                else 
                    dvdu = 1;
                end
                dk = v(k) - v_hat;
        
                for m = 1:N
                    if m == 1
                        y_0(m) = -a*[y(k) y(k-1)]' + dvdu*b*[u_10 u_10]' + dvdu*b*[u_20 u_20]' + dk;
                    elseif m == 2
                        y_0(m) = -a*[y_0(m-1) y(k)]' + dvdu*b*[u_10 u_10]' + dvdu*b*[u_20 u_20]' + dk;
                    else
                        y_0(m) = -a*[y_0(m-1) y_0(m-2)]' + dvdu*b*[u_10 u_10]' + dvdu*b*[u_20 u_20]' + dk;
                    end
                end
            end
        end

        function [y, u, E, E_u, E_y] = dmc_slWiener(obj, y_zad, u_D, a, b, fis, delay, kk, type)
            %% Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;
        
            delta_up = zeros(1, obj.D-1);
            delta_uz = zeros(1, obj.D_disturbance);
            delta_uk = 0;
            delta_u = zeros(1, kk);
            dv = 0.001;
            
            %% Sterowanie DMC
            v = zeros(size(y_zad));
            y = zeros(size(v));
            v(1:delay+2) = y_zad(1:delay+2);
            y(1:delay+2) = y_zad(1:delay+2);
        
            for k = delay+3:kk
                v(k) = - a*v(k-1:-1:k-2)' + b*u(1, k-(delay+1):-1:k-(delay+2))' + b*u(2, k-1:-1:k-2)';
                y(k) = ((120+v(k))/20)^2 - 36;
        
                % Ograniczenia wartości sygnału wyjściowego
                y(k) = min(y(k), obj.y_max);
                y(k) = max(y(k), -obj.y_max);
        
                if strcmp(type, 'linear')
                    dydv = (evalfis(fis, v(k)) - evalfis(fis, v(k)-dv)) / dv;
                else
                    gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
        
                    output = 0;
                    w = 0;
                    for i = 1:fis.rules_number
                        degrees = gaussmf_val(v(k), fis.sigma, fis.Y_center(i));
                        output = output + degrees * (fis.a_param(i)*sinh(v(k)/36) + fis.b_param(i));
                        w = w + degrees;
                    end
                    y_k = output / w;
        
                    output = 0;
                    w = 0;
                    for i = 1:fis.rules_number
                        degrees = gaussmf_val(v(k)-dv, fis.sigma, fis.Y_center(i));
                        output = output + degrees * (fis.a_param(i)*sinh((v(k)-dv)/36) + fis.b_param(i));
                        w = w + degrees;
                    end
                    y_k_1 = output / w;
                    dydv = (y_k - y_k_1) / dv;
                end
        
                M_new = dydv * obj.M;
                K_new = ((M_new' * M_new + obj.lambda * eye(obj.Nu))^(-1)) * M_new';
                ke_new = sum(K_new(1, :));
        
                Mp_new = dydv * obj.M_p;
                ku_new = K_new(1,:) * Mp_new;
        
                MzP_new = dydv * obj.M_zP;
                kz_new = K_new(1,:) * MzP_new;
        
                % Przepisanie sterowań do wektora przeszłych sterowań
                delta_up = [delta_uk, delta_up(1:end-1)];
                delta_uz = [u(2, k) - u(2, k-1), delta_uz(1:end-1)];
        
                % Oblicznie uchybu    
                e = y_zad(k) - y(k);

                % Obliczenie przyrostu sterowania
                delta_uk = ke_new * e - ku_new * delta_up' - kz_new * delta_uz';
        
                % Ograniczenie wartości przyrostu sterowania
                delta_uk = min(delta_uk, obj.delta_uk_max);
                delta_uk = max(delta_uk, -obj.delta_uk_max);
                delta_u(k) = delta_uk;
        
                % Obliczenie sterowania
                u(1, k) = u(1, k-1) + delta_uk;
        
                % Ograniczenie sterowania
                u(1, k) = min(u(1, k), obj.u_max);
                u(1, k) = max(u(1, k), -obj.u_max);
            end
        
            E_u = obj.lambda .* sum(delta_u.^2)/kk;
            E_y = sum((y_zad - y).^2)/kk;
            E = E_u + E_y;
        end

        function [y, u, E, E_u, E_y] = dmc_nplWiener(obj, y_zad, u_D, a, b, fis, delay, kk, type)
            %% Alokacja pamięci
            u = zeros(2, kk);
            u(2,:) = u_D;
        
            delta_u = zeros(1, kk);
            dv = 0.001;
            
            %% Sterowanie DMC
            v = zeros(size(y_zad));
            y = zeros(size(y_zad));
            v(1:delay+2) = y_zad(1:delay+2);
            y(1:delay+2) = y_zad(1:delay+2);
        
            for k = delay+3:kk
                v(k) = - a*v(k-1:-1:k-2)' + b*u(1, k-(delay+1):-1:k-(delay+2))' + b*u(2, k-1:-1:k-2)';
                y(k) = ((120 + v(k))/20)^2 - 36;
        
                if strcmp(type, 'linear')
                    dydu = (evalfis(fis, v(k)) - evalfis(fis, v(k)-dv)) / dv;
                else
                    gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
        
                    output = 0;
                    w = 0;
                    for i = 1:fis.rules_number
                        degrees = gaussmf_val(v(k), fis.sigma, fis.Y_center(i));
                        output = output + degrees * (fis.a_param(i)*sinh(v(k)/36) + fis.b_param(i));
                        w = w + degrees;
                    end
                    y_k = output / w;
        
                    output = 0;
                    w = 0;
                    for i = 1:fis.rules_number
                        degrees = gaussmf_val(v(k)-dv, fis.sigma, fis.Y_center(i));
                        output = output + degrees * (fis.a_param(i)*sinh((v(k)-dv)/36) + fis.b_param(i));
                        w = w + degrees;
                    end
                    y_k_1 = output / w;
        
                    dydu = (y_k - y_k_1) / dv;
                end
        
                M_new = dydu * obj.M;
                K_new = ((M_new' * M_new + obj.lambda * eye(obj.Nu))^(-1)) * M_new';
        
                Y_0 = fuzzy_free_response(u, v, y, k, a, b, obj.N, fis, type);
                Y_zad = y_zad(k) * ones(obj.N, 1);
                delta_uk = K_new(1,:) * (Y_zad - Y_0);
        
                % Ograniczenia przyrostu
                delta_uk = min(max(delta_uk, -obj.delta_uk_max), obj.delta_uk_max);
        
                % Aktualizacja sterowania
                u(1, k) = u(1, k-1) + delta_uk;
        
                % Ograniczenia sterowania
                u(1, k) = min(u(1, k), obj.u_max);
                u(1, k) = max(u(1, k), -obj.u_max);
        
                delta_u(k) = delta_uk;
            end
        
            E_u = obj.lambda .* sum(delta_u.^2) / kk;
            E_y = sum((y_zad - y).^2) / kk;
            E = E_u + E_y;
        
            function y_0 = fuzzy_free_response(u, v, y, k, a, b, N, fis, type)
                % gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

                y_0 = zeros(N, 1);
                v_0 = zeros(N, 1);
                u_10 = u(1, k-6);
                u_20 = u(2, k-1);
        
                if (strcmp(type, 'linear'))
                    y_hat = evalfis(fis, v(k));
                else
                    output = 0;
                    w = 0;
                    for j = 1:fis.rules_number
                        degrees = gaussmf_val(v(k), fis.sigma, fis.Y_center(j));
                        output = output + degrees * (fis.a_param(j)*sinh(v(k)/36) + fis.b_param(j));
                        w = w + degrees;
                    end
                    y_hat = output / w;
                end

                dk = y(k) - y_hat;
        
                for j = 1:N
                    if j == 1
                        v_0(j) = -a*[v(k) v(k-1)]' + b*[u_10 u_10]' + b*[u_20 u_20]';
                    elseif j == 2
                        v_0(j) = -a*[v_0(j-1) v(k)]' + b*[u_10 u_10]' + b*[u_20 u_20]';
                    else
                        v_0(j) = -a*[v_0(j-1) v_0(j-2)]' + b*[u_10 u_10]' + b*[u_20 u_20]';
                    end
                end
        
                for j = 1:N
                    if (strcmp(type, 'linear'))
                        y0 = evalfis(fis, v_0(j));
                    else
                        output = 0;
                        w = 0;
                        for l = 1:fis.rules_number
                            degrees = gaussmf_val(v_0(j), fis.sigma, fis.Y_center(l));
                            output = output + degrees * (fis.a_param(l)*sinh(v_0(j)/36) + fis.b_param(l));
                            w = w + degrees;
                        end
                        y0 = output / w;
                    end
                    y_0(j) = y0 + dk;
                end
            end
        end
       
        function show_result(~, y_mod, y_zad, u, E, E_u, E_y, kk, s, t)
            fprintf("Błąd DMC-%s (%s) \t E_u: %.3f \n", s, t, E_u);
            fprintf("Błąd DMC-%s (%s) \t E_y: %.3f \n", s, t, E_y);
            fprintf("Błąd DMC-%s (%s) \t E = %.3f \n\n", s, t, E);

            figure;
            hold on;
            stairs(0:kk-1, y_mod, 'b-', 'LineWidth', 0.8);
            stairs(0:kk-1, y_zad, 'r-', 'LineWidth', 0.8);
            hold off;
            legend('y', 'y_{zad}', 'Location', 'best');
            title(sprintf('Sygnał wyjściowy y(k) \t DMC - %s \t %s', s, t));
            xlabel('k');
            ylabel('y(k)');
            grid on;
            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/y_%s%s.png', s, t));  % Zapisuje jako plik PNG

            figure;
            hold on;
            stairs(0:kk-1, u(1,:), 'b-', 'LineWidth', 0.8);
            hold off;
            legend('u', 'Location', 'best');
            title(sprintf('Sygnał sterujący u(k) \t DMC - %s \t %s', s, t));
            xlabel('k');
            ylabel('u(k)');
            grid on;
            % saveas(gcf, sprintf('D:/EiTI/MGR/raporty/raport_MGR/pictures/u_%s%s.png', s, t));  % Zapisuje jako plik PNG
        end

    end
end