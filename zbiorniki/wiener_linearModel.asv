%% LINEAR HAMMERSTEIN MODEL
clear all;
obiekt = Obiekt();
[~, ~, a, b, G_z, G_s] = obiekt.linearization(90, 30);

% Zakres sterowania
U_min = -45;
U_max = 45;
U_center = linspace(U_min, U_max, 5); % Środek zbiorów

%Generacja danych sterujących i RK4
U = linspace(-45, 45, obiekt.kk);
Y = ((obiekt.F_10+U + obiekt.F_D0) / obiekt.alpha_2).^2;
t = (0:length(U)-1) * obiekt.Tp; % Czas w sekundach (próbkowanie = 20s)

%% 2. Tworzenie początkowego systemu rozmytego TS
close all;
fis = sugfis('Name', 'Hammerstein', 'Type', 'sugeno');
fis = addInput(fis, [U_min U_max], 'Name', 'U');

% Definiowanie funkcji przynależności (gaussmf)
for i = 1:length(U_center) 
    fis = addMF(fis, 'U', 'gaussmf', [12, U_center(i)]);
end

% Definiowanie wyjścia i początkowych następników (a_i * u + b_i)
fis = addOutput(fis, [U_min U_max], 'Name', 'U_fuzzy');

% Początkowe współczynniki (a_i, b_i)
% a_param = ones(1,5)*0.5;
% b_param = ones(1,5)*35;

% Optymalne parametry a: 
a_param = [0.3647    0.4227    0.4844    0.5657    0.6796];
% Optymalne parametry b: 
b_param = [30.4365   33.2982   36.0644   38.2423   38.0915];

% Dodanie reguł TS w postaci liniowej
for i = 1:length(U_center)
    fis = addMF(fis, 'U_fuzzy', 'linear', [a_param(i), b_param(i)]);
end

% Reguły Takagi-Sugeno: [inputMF, outputMF, weight]
ruleList = [1 1 1 1;
            2 2 1 1;
            3 3 1 1;
            4 4 1 1;
            5 5 1 1];

% Dodanie reguł do systemu
fis = addRule(fis, ruleList);

% % Optymalizacja przy pomocy fminsearch
% initial_params = [a_param, b_param];  % Początkowe wartości a_param i b_param
% options = optimset('Display', 'iter', 'MaxFunEvals', 2000, 'MaxIter', 1000); % Opcje optymalizacji
% optimal_params = fminsearch(@(params) linearCoeff(params, fis, U, Y, length(fis.Rules)), initial_params, options);

% Po optymalizacji
% a_optimal = optimal_params(1:5);
% b_optimal = optimal_params(6:end);
a_optimal = a_param;
b_optimal = b_param;

% Wyświetlanie wyników optymalizacji
fprintf('Optymalne parametry a: \n');
disp(a_optimal);
fprintf('Optymalne parametry b: \n');
disp(b_optimal);

%% Check fuzzy static
for i = 1:length(fis.Rules)
    fis.Outputs.MembershipFunctions(i).Parameters(1) = a_optimal(i);
    fis.Outputs.MembershipFunctions(i).Parameters(2) = b_optimal(i);
end

Y_fuzzy = evalfis(fis, U);
plot(U, Y, 'b-', U, Y_fuzzy, 'ro');
grid on;

%% Identyfikacja dynamiki
U = [ones(1, 100)
    zeros(1, 100)];
[Y_step, ~] = obiekt.rk4(U, 100);
% Normalizacja odpowiedzi skokowej
Y_step = Y_step / Y_step(end);
t = (0:length(U)-1) * obiekt.Tp; % Czas w sekundach (próbkowanie = 20s)

% Funkcja celu (error)
fun = @(T) model_error(T, U, Y_step, obiekt);

% Startowa wartość (70)
T0 = [50, 50];
% Optymalna stała czasowa 
T0 = [193.4125      36.78401

% Szukanie optymalnej stałej czasowej
options = optimset('Display', 'iter', 'MaxFunEvals', 2000, 'MaxIter', 1000); % Opcje optymalizacji
T_opt = fminsearch(fun, T0, options);

% Wyświetlenie wyniku
disp(['Optymalna stała czasowa T = ', num2str(T_opt)]);

G = tf(1, conv([T_opt(1), 1], [T_opt(2), 1]));
G.InputDelay = obiekt.tau;
G_z = c2d(G, obiekt.Tp, 'zoh');
G_z.Variable = 'z^-1';

Y = zeros(size(Y_step));
Y(1:7) = Y_step(1:7);
for k = 8:length(U)
    Y(k) = - G_z.Denominator{1}(2)*Y(k-1) - G_z.Denominator{1}(3)*Y(k-2) ...
        + G_z.Numerator{1}(2)*U(1, k-6) + G_z.Numerator{1}(3)*U(1, k-7) ...
        + G_z.Numerator{1}(2)*U(2, k-1) + G_z.Numerator{1}(3)*U(2, k-2);
end

plot(t, Y_step, 'b', t, Y, 'g');
grid on;

%% Losowość
U = [repelem((rand(1, obiekt.kk/400) * 90 - 45), 400)
    zeros(1, obiekt.kk)];
[Y_real, Y_lin] = obiekt.rk4(U, obiekt.kk);
t = (0:length(U)-1) * obiekt.Tp; % Czas w sekundach (próbkowanie = 20s)

Y_0 = evalfis(fis, 0);
Y = zeros(1,obiekt.kk);
Y_fuzzy = zeros(1, obiekt.kk);

for k = 8:obiekt.kk
    Y(k) = - G_z.Denominator{1}(2)*Y(k-1) - G_z.Denominator{1}(3)*Y(k-2) ...
        + G_z.Numerator{1}(2)*U(1, k-6) + G_z.Numerator{1}(3)*U(1, k-7) ...
        + G_z.Numerator{1}(2)*U(2, k-1) + G_z.Numerator{1}(3)*U(2, k-2);

    Y_fuzzy(k) = evalfis(fis, U(1,:)) - obiekt.h_20;
end

plot(t, Y_real, 'b');
hold on;
plot(t, Y_lin, 'r');
plot(t, Y_fuzzy, 'g');
grid on;
legend('Y_{real}', 'Y_{lin}', 'Y');

%% Funkcja do optymalizacji współczynników
function E_out = linearCoeff(params, fis, U, Y, rules_number)
    %gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

    % Parametry do optymalizacji
    a_param = params(1:rules_number);
    b_param = params(rules_number+1:end);

    for i = 1:rules_number
        fis.Outputs.MembershipFunctions(i).Parameters(1) = a_param(i);
        fis.Outputs.MembershipFunctions(i).Parameters(2) = b_param(i);
    end
    
    Y_out = zeros(size(U));
    E_out = 0;
    % Oblicz odpowiedzi systemu rozmytego dla wszystkich U
    for i = 1:length(U)
        Y_out(i) = evalfis(fis, U(i));
        % Funkcja kosztu - suma kwadratów błędów
        E_out = E_out + sum((Y(i) - Y_out(i))^2);
    end
end

function E = model_error(T, U, Y_step, obiekt)
    % Tworzenie nowej transmitancji z aktualnym T
    G = tf(1, conv([T(1), 1], [T(2), 1]));
    G.InputDelay = obiekt.tau;
    
    % Dyskretyzacja
    G_z = c2d(G, obiekt.Tp, 'zoh');
    G_z.Variable = 'z^-1';
    
    % Symulacja wyjścia Y
    Y = zeros(size(Y_step));
    Y(1:7) = Y_step(1:7); % załadowanie początkowych wartości (warunki początkowe)
    for k = 8:length(U)
        Y(k) = - G_z.Denominator{1}(2)*Y(k-1) - G_z.Denominator{1}(3)*Y(k-2) ...
            + G_z.Numerator{1}(2)*U(1, k-6) + G_z.Numerator{1}(3)*U(1, k-7) ...
            + G_z.Numerator{1}(2)*U(2, k-1) + G_z.Numerator{1}(3)*U(2, k-2);
    end
    
    E = sum((Y - Y_step).^2);
end