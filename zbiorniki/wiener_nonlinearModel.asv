%% LINEAR HAMMERSTEIN MODEL
clear all;
obiekt = Obiekt();
obiekt.linearization(90, 30);

%% Identyfikacja dynamiki
U = [ones(1, 100)
    zeros(1, 100)];
[Y_step, ~] = obiekt.rk4(U, 100);
% Normalizacja odpowiedzi skokowej
Y_step = Y_step / Y_step(end);
t = (0:length(U)-1) * obiekt.Tp; % Czas w sekundach (próbkowanie = 20s)

% Funkcja celu (error)
fun = @(T) model_error(T, U, Y_step, obiekt);

% Startowa wartość (70)
% T0 = [50, 50];
% Optymalna stała czasowa 
T0 = [193.4125      36.78401];

% Szukanie optymalnej stałej czasowej
% options = optimset('Display', 'iter', 'MaxFunEvals', 2000, 'MaxIter', 1000); % Opcje optymalizacji
% T_opt = fminsearch(fun, T0, options);
T_opt = T0;

% Wyświetlenie wyniku
disp(['Optymalna stała czasowa T = ', num2str(T_opt)]);

G = tf(1, conv([T_opt(1), 1], [T_opt(2), 1]));
G.InputDelay = obiekt.tau;
G_z = c2d(G, obiekt.Tp, 'zoh');
G_z.Variable = 'z^-1';

Y = zeros(size(Y_step));
Y(1:7) = Y_step(1:7);
for k = 8:length(U)
    Y(k) = - G_z.Denominator{1}(2)*Y(k-1) - G_z.Denominator{1}(3)*Y(k-2) ...
        + G_z.Numerator{1}(2)*U(1, k-6) + G_z.Numerator{1}(3)*U(1, k-7) ...
        + G_z.Numerator{1}(2)*U(2, k-1) + G_z.Numerator{1}(3)*U(2, k-2);
end

plot(t, Y_step, 'b', t, Y, 'g');
grid on;

%% Tworzenie początkowego systemu rozmytego TS
close all;

%Generacja danych sterujących i RK4
U = linspace(-45, 45, obiekt.kk);
Y = ((obiekt.F_10+U + obiekt.F_D0) / obiekt.alpha_2).^2;
t = (0:length(U)-1) * obiekt.Tp; % Czas w sekundach (próbkowanie = 20s)

h = zeros(1, obiekt.kk);
y = zeros(1, 100);
for i = 1:obiekt.kk
    u = [ones(1,100) * U(i);
        zeros(1,100)];
    % [y, ~] = obiekt.rk4(u, 100);
    for k = 8:length(u)
        y(k) = - G_z.Denominator{1}(2)*y(k-1) - G_z.Denominator{1}(3)*y(k-2) ...
            + G_z.Numerator{1}(2)*u(1, k-6) + G_z.Numerator{1}(3)*u(1, k-7) ...
            + G_z.Numerator{1}(2)*u(2, k-1) + G_z.Numerator{1}(3)*u(2, k-2);
    end
    h(i) = y(end);
end

disp([min(h), max(h)]');

%% System rozmyty
% Zakres sterowania
Y_min = min(h);
Y_max = max(h);
Y_center = linspace(Y_min, Y_max, 3); % Środek zbiorów

fis = sugfis('Name', 'Wiener', 'Type', 'sugeno');
fis = addInput(fis, [Y_min Y_max], 'Name', 'Y');

% Definiowanie funkcji przynależności (gaussmf)
for i = 1:length(Y_center) 
    fis = addMF(fis, 'Y', 'gaussmf', [25, Y_center(i)]);
end

% Definiowanie wyjścia i początkowych następników (a_i * u + b_i)
fis = addOutput(fis, [Y_min Y_max], 'Name', 'Y_fuzzy');

% Początkowe współczynniki (a_i, b_i)
% a_param = ones(1,3)*0.9;
% b_param = ones(1,3)*10;
% c_param = ones(1,3)*38;

% Optymalne parametry a: 
a_param = [0.4039    1.3416    0.3739];
% Optymalne parametry b: 
b_param = [17.1217   22.6325   11.9320];
% Optymalne parametry c: 
c_param = [13.8112   34.3922   65.9774];

% Dodanie reguł TS w postaci liniowej
for i = 1:length(Y_center)
    fis = addMF(fis, 'Y_fuzzy', 'linear', [a_param(i), b_param(i)]);
end

% Reguły Takagi-Sugeno: [inputMF, outputMF, weight]
ruleList = [1 1 1 1;
            2 2 1 1;
            3 3 1 1];

% Dodanie reguł do systemu
fis = addRule(fis, ruleList);

% % Optymalizacja przy pomocy fminsearch
% initial_params = [a_param, b_param];  % Początkowe wartości a_param i b_param
% options = optimset('Display', 'iter', 'MaxFunEvals', 2000, 'MaxIter', 1000); % Opcje optymalizacji
% optimal_params = fminsearch(@(params) linearCoeff(params, fis, h, Y, length(fis.Rules)), initial_params, options);

% Po optymalizacji
% a_optimal = optimal_params(1:5);
% b_optimal = optimal_params(6:end);
a_optimal = a_param;
b_optimal = b_param;
c_optimal = c_param;

% Wyświetlanie wyników optymalizacji
fprintf('Optymalne parametry a: \n');
disp(a_optimal);
fprintf('Optymalne parametry b: \n');
disp(b_optimal);
fprintf('Optymalne parametry c: \n');
disp(c_optimal);

%% Check fuzzy static
gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));
Y_out = zeros(size(U));
for k = 1:length(U)
    output = 0;
    w = 0;
    degrees = [gaussmf_val(h(k), sigma, U_center(1)), ...
               gaussmf_val(h(k), sigma, U_center(2)), ...
               gaussmf_val(h(k), sigma, U_center(3))];
    for i = 1:length(fis.Rules)
        output = output +  degrees(i) * (a_optimal(i)*sinh(h(k)/b_optimal(i)) + c_optimal(i));
        w = w + degrees(i);
    end
    Y_out(k) = output / w;
end

plot(h, Y, 'b-', h, Y_fuzzy, 'ro');
grid on;

%% Losowość
U = [repelem((rand(1, obiekt.kk/400) * 90 - 45), 400)
    zeros(1, obiekt.kk)];
[Y_real, Y_lin] = obiekt.rk4(U, obiekt.kk);
t = (0:length(U)-1) * obiekt.Tp; % Czas w sekundach (próbkowanie = 20s)

Y_0 = evalfis(fis, 0);
Y = zeros(1,obiekt.kk);
Y_fuzzy = zeros(1, obiekt.kk);

for k = 8:obiekt.kk
    Y(k) = - G_z.Denominator{1}(2)*Y(k-1) - G_z.Denominator{1}(3)*Y(k-2) ...
        + G_z.Numerator{1}(2)*U(1, k-6) + G_z.Numerator{1}(3)*U(1, k-7) ...
        + G_z.Numerator{1}(2)*U(2, k-1) + G_z.Numerator{1}(3)*U(2, k-2);
    Y_fuzzy(k) = evalfis(fis, Y(k)) - obiekt.h_20;
end

plot(t, Y_real, 'b');
hold on;
plot(t, Y_lin, 'r');
plot(t, Y_fuzzy, 'g');
grid on;
legend('Y_{real}', 'Y_{lin}', 'Y_fuzzy');

%% Funkcja do optymalizacji współczynników
function E_out = nonlinearCoeff(params, fis, U, Y, rules_number)
    %gaussmf_val = @(x, sigma, c) exp(-((x - c).^2) / (2 * sigma^2));

    % Parametry do optymalizacji
    a_param = params(1:rules_number);
    b_param = params(rules_number+1:end);

    for i = 1:rules_number
        fis.Outputs.MembershipFunctions(i).Parameters(1) = a_param(i);
        fis.Outputs.MembershipFunctions(i).Parameters(2) = b_param(i);
    end
    
    Y_out = zeros(size(U));
    E_out = 0;
    % Oblicz odpowiedzi systemu rozmytego dla wszystkich U
    for i = 1:length(U)
        Y_out(i) = evalfis(fis, U(i));
        % Funkcja kosztu - suma kwadratów błędów
        E_out = E_out + sum((Y(i) - Y_out(i))^2);
    end
end

function E = model_error(T, U, Y_step, obiekt)
    % Tworzenie nowej transmitancji z aktualnym T
    G = tf(1, conv([T(1), 1], [T(2), 1]));
    G.InputDelay = obiekt.tau;
    
    % Dyskretyzacja
    G_z = c2d(G, obiekt.Tp, 'zoh');
    G_z.Variable = 'z^-1';
    
    % Symulacja wyjścia Y
    Y = zeros(size(Y_step));
    Y(1:7) = Y_step(1:7); % załadowanie początkowych wartości (warunki początkowe)
    for k = 8:length(U)
        Y(k) = - G_z.Denominator{1}(2)*Y(k-1) - G_z.Denominator{1}(3)*Y(k-2) ...
            + G_z.Numerator{1}(2)*U(1, k-6) + G_z.Numerator{1}(3)*U(1, k-7) ...
            + G_z.Numerator{1}(2)*U(2, k-1) + G_z.Numerator{1}(3)*U(2, k-2);
    end
    
    E = sum((Y - Y_step).^2);
end